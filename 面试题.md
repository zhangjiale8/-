# 1. == 与equals的区别？equals原理

== 是地址比较

equals是值比较

基本数据类型用==

基本类型的包装类重写了equals方法

 Object类中的equals方法和“==”是一样的，没有区别，即俩个对象的比较是比较他们的栈内存中存储的内存地址。而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，他们比较的是值是不是相等。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法

1.  ==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
2. ==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较
3. ==指引用是否相同， equals()指的是值是否相同

 如果两个对象相同，那么它们的hashCode值一定要相同。也告诉我们重写equals方法，一定要重写hashCode方法，也就是说hashCode值要和类中的成员变量挂上钩，对象相同–>成员变量相同—->hashCode值一定相同。 
如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较

# 2. 线程池原理

https://www.jianshu.com/p/125ccf0046f3



# 3. 五种线程池的分类和作用

https://www.cnblogs.com/vince66/p/9325638.html

# 4.阻塞队列原理

https://www.jb51.net/article/117204.htm

# 5. spring声明式事务原理

https://blog.csdn.net/sinat_34341162/article/details/84192023

#  6. 动态代理原理

https://www.jianshu.com/p/85d181d7d09a



# 7 SpringBoot自动装配原理

https://blog.csdn.net/Dongguabai/article/details/80865599

# 8 java注解

https://blog.csdn.net/yuzongtao/article/details/83306182

# 9 千万级数据量主键，单据号生成

https://bbs.csdn.net/topics/260075534

https://blog.csdn.net/jiabeis/article/details/80999498

雪花算法

https://blog.csdn.net/u012516166/article/details/76559526

# 10 数据库索引

https://www.cnblogs.com/phpdragon/p/8231533.html

https://blog.csdn.net/tongdanping/article/details/79878302

主键索引、唯一索引、普通索引、全文索引（FULLTEXT，不能使用like）、组合索引

```sql
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```



# 11 生产者消费者模式

https://www.cnblogs.com/luego/p/12048857.html

https://blog.csdn.net/sanyuesan0000/article/details/52996586

java实现：

https://blog.csdn.net/shadowcw/article/details/82352829



# 12 设计模式

https://www.javazhiyin.com/zx/sjms/page/6



# 13 两个线程交替打印1-100

```java
public class PrintNum {
    private static Object lock = new Object();
    private static volatile int num = 0;
    public class PrintThread implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                while (num < 100){
                    System.out.println(Thread.currentThread().getName() + "打印：" + ++num);
                    lock.notifyAll();
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    @Test
    public void test(){java
        new Thread(new PrintThread(),"thread1").start();
        new Thread(new PrintThread(),"thread2").start();
    }
}
```

# 14 链表反转

```Java
public class Reverse {
    //单链表
    static class ListNode{
        int val;
        ListNode next;
        public ListNode(int val){
            this.val=val;
        }
    }
    //翻转方法
    public static ListNode reverse(ListNode head){
        //指定当前节点的前驱
        ListNode pre=null;
        //当前节点
        ListNode cur=head;
        //当前节点的后继
        ListNode next=null;
        //因为这里每次执行后都是将next赋给了cur，所以需要判断cur
        while (cur!=null){
            //保存当前节点的后继
            next=cur.next;
            //将当前节点后继改成前驱，这也是翻转最重要的一步，头结点的后继应该为空
            cur.next=pre;
            //依次向后移动一个单位，执行完成后，pre指的是翻转前最后的节点，也就是翻转后的头结点
            pre=cur;
            cur=next;
        }
        return pre;
    }
    public static void main(String[] args) {
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        ListNode node4 = new ListNode(4);
        ListNode node5 = new ListNode(5);
        ListNode node6 = new ListNode(6);
        node1.next=node2;
        node2.next=node3;
        node3.next=node4;
        node4.next=node5;
        node5.next=node6;
        ListNode reverse = reverse(node1);
        while (reverse!=null){
            System.out.println(reverse.val);
            reverse=reverse.next;
        }
    }
```

# 15 linux 常用操作命令

https://www.cnblogs.com/banjinbaijiu/p/9140460.html

# 16 Mybatis mapper动态代理的原理详解

https://www.cnblogs.com/hopeofthevillage/p/11384848.html



# 17 线程隔离 ThreadLocal

https://www.cnblogs.com/beatIteWeNerverGiveUp/p/5950440.html

# 18 Dubbo原理简述一：RPC原理和Netty通信原理

https://blog.csdn.net/qq_33404395/article/details/86497215

# 19 最全面的阿里多线程面试题，你能回答几个？

https://blog.csdn.net/qq_20499001/article/details/99978083

# 21 Java中的常量类缓存机制

https://cloud.tencent.com/developer/article/1451236

# 22 同步锁实现，与Lock的区别 1.8中的优化，可重入锁，偏向锁

https://www.cnblogs.com/my376908915/p/6757833.html

https://www.cnblogs.com/linghu-java/p/8944784.html

https://www.pianshen.com/article/3799167501/

https://www.pianshen.com/article/3799167501/

# 23 HashMap中链表转红黑树条件 长度8，达到阀值

https://www.pianshen.com/article/8845315407/

# 24 cureentHashMaP实现；1.8后的优化



https://www.jianshu.com/p/e694f1e868ec

# 25 数据库索引

# 26 JVM，类加载，java->jvm中，垃圾回收器



# 27 zk协议，选举



# 28 Redis集群



# 29 链表

https://blog.csdn.net/weixin_41445507/article/details/89074868

https://blog.csdn.net/qq_41027326/article/details/79787434

https://www.jianshu.com/p/81a6ed0abeb8

https://blog.csdn.net/qq_41966475/article/details/105217145

https://blog.csdn.net/qq_15720911/article/details/76945226?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control



https://blog.csdn.net/u010442302/article/details/51864187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control



# 30 osi七层模型从下到上分别为：

1、物理层：建立、维bai护、断开物理连接。

TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。

2、数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。

将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。

3、网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。

协议有：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP。



4、传输层：定义传输数据的协议端口号，以及流控和差错校验。

协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层。

5、会话层：建立、管理、终止会话。

对应主机进程，指本地主机与远程主机正在进行的会话。

6、表示层：数据的表示、安全、压缩。

格式有JPEG、ASCll、DECOIC、加密格式等。

7、应用层：网络服务与最终用户的一个接口。

协议有：HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP

https://zhidao.baidu.com/question/571359857.html

# 31 详细说一下一个浏览器发出去一个请求都经过了那些步骤

https://www.cnblogs.com/xsj1/p/11202277.html

https://www.cnblogs.com/windy-xmwh/p/9296253.html

https://blog.csdn.net/wnx_52055/article/details/88353441?utm_medium=distribute.pc_relevant.none-task-blog-title-15&spm=1001.2101.3001.4242

# 32 阿里面试题

https://www.jb51.net/it/667282.html

# 33 中移面试

https://www.nowcoder.com/discuss/303907?type=2&order=3&pos=5&page=1&channel=-2&source_id=discuss_tag