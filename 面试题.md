# 1. == 与equals的区别？equals原理

== 是地址比较

equals是值比较

基本数据类型用==

基本类型的包装类重写了equals方法

 Object类中的equals方法和“==”是一样的，没有区别，即俩个对象的比较是比较他们的栈内存中存储的内存地址。而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，他们比较的是值是不是相等。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法

1.  ==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
2. ==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较
3. ==指引用是否相同， equals()指的是值是否相同

 如果两个对象相同，那么它们的hashCode值一定要相同。也告诉我们重写equals方法，一定要重写hashCode方法，也就是说hashCode值要和类中的成员变量挂上钩，对象相同–>成员变量相同—->hashCode值一定相同。 
如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较

# 2. 线程池原理

https://www.jianshu.com/p/125ccf0046f3



# 3. 五种线程池的分类和作用

https://www.cnblogs.com/vince66/p/9325638.html

# 4.阻塞队列原理

https://www.jb51.net/article/117204.htm

# 5. spring声明式事务原理

https://blog.csdn.net/sinat_34341162/article/details/84192023

#  6. 动态代理原理

https://www.jianshu.com/p/85d181d7d09a



# 7 SpringBoot自动装配原理

https://blog.csdn.net/Dongguabai/article/details/80865599

# 8 java注解

https://blog.csdn.net/yuzongtao/article/details/83306182

# 9 千万级数据量主键，单据号生成

https://bbs.csdn.net/topics/260075534

https://blog.csdn.net/jiabeis/article/details/80999498

雪花算法

https://blog.csdn.net/u012516166/article/details/76559526

# 10 数据库索引

https://www.cnblogs.com/phpdragon/p/8231533.html

https://blog.csdn.net/tongdanping/article/details/79878302

主键索引、唯一索引、普通索引、全文索引（FULLTEXT，不能使用like）、组合索引

```sql
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```



# 11 生产者消费者模式

https://www.cnblogs.com/luego/p/12048857.html

https://blog.csdn.net/sanyuesan0000/article/details/52996586

java实现：

https://blog.csdn.net/shadowcw/article/details/82352829



# 12 设计模式

https://www.javazhiyin.com/zx/sjms/page/6



# 13 两个线程交替打印1-100

```java
public class PrintNum {
    private static Object lock = new Object();
    private static volatile int num = 0;
    public class PrintThread implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                while (num < 100){
                    System.out.println(Thread.currentThread().getName() + "打印：" + ++num);
                    lock.notifyAll();
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    @Test
    public void test(){java
        new Thread(new PrintThread(),"thread1").start();
        new Thread(new PrintThread(),"thread2").start();
    }
}
```

# 14 链表反转

```Java
public class Reverse {
    //单链表
    static class ListNode{
        int val;
        ListNode next;
        public ListNode(int val){
            this.val=val;
        }
    }
    //翻转方法
    public static ListNode reverse(ListNode head){
        //指定当前节点的前驱
        ListNode pre=null;
        //当前节点
        ListNode cur=head;
        //当前节点的后继
        ListNode next=null;
        //因为这里每次执行后都是将next赋给了cur，所以需要判断cur
        while (cur!=null){
            //保存当前节点的后继
            next=cur.next;
            //将当前节点后继改成前驱，这也是翻转最重要的一步，头结点的后继应该为空
            cur.next=pre;
            //依次向后移动一个单位，执行完成后，pre指的是翻转前最后的节点，也就是翻转后的头结点
            pre=cur;
            cur=next;
        }
        return pre;
    }
    public static void main(String[] args) {
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        ListNode node4 = new ListNode(4);
        ListNode node5 = new ListNode(5);
        ListNode node6 = new ListNode(6);
        node1.next=node2;
        node2.next=node3;
        node3.next=node4;
        node4.next=node5;
        node5.next=node6;
        ListNode reverse = reverse(node1);
        while (reverse!=null){
            System.out.println(reverse.val);
            reverse=reverse.next;
        }
    }
```

# 15 linux 常用操作命令

