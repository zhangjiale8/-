# 1. == 与equals的区别？equals原理

== 是地址比较

equals是值比较

基本数据类型用==

基本类型的包装类重写了equals方法

 Object类中的equals方法和“==”是一样的，没有区别，即俩个对象的比较是比较他们的栈内存中存储的内存地址。而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，他们比较的是值是不是相等。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法

1.  ==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
2. ==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较
3. ==指引用是否相同， equals()指的是值是否相同

 如果两个对象相同，那么它们的hashCode值一定要相同。也告诉我们重写equals方法，一定要重写hashCode方法，也就是说hashCode值要和类中的成员变量挂上钩，对象相同–>成员变量相同—->hashCode值一定相同。 
如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较

# 2. 线程池原理

https://www.jianshu.com/p/125ccf0046f3



# 3. 五种线程池的分类和作用

https://www.cnblogs.com/vince66/p/9325638.html

# 4.阻塞队列原理

https://www.jb51.net/article/117204.htm

# 5. spring声明式事务原理

https://blog.csdn.net/sinat_34341162/article/details/84192023

#  6. 动态代理原理

https://www.jianshu.com/p/85d181d7d09a



# 7 SpringBoot自动装配原理

https://blog.csdn.net/Dongguabai/article/details/80865599

# 8 java注解

https://blog.csdn.net/yuzongtao/article/details/83306182

# 9 千万级数据量主键，单据号生成

https://bbs.csdn.net/topics/260075534

https://blog.csdn.net/jiabeis/article/details/80999498

雪花算法

https://blog.csdn.net/u012516166/article/details/76559526

# 10 数据库索引

https://www.cnblogs.com/phpdragon/p/8231533.html

https://blog.csdn.net/tongdanping/article/details/79878302

主键索引、唯一索引、普通索引、全文索引（FULLTEXT，不能使用like）、组合索引

```sql
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```



# 11 生产者消费者模式

https://www.cnblogs.com/luego/p/12048857.html

https://blog.csdn.net/sanyuesan0000/article/details/52996586

java实现：

https://blog.csdn.net/shadowcw/article/details/82352829



# 12 设计模式

https://www.javazhiyin.com/zx/sjms/page/6



# 13 两个线程交替打印1-100

```java
public class PrintNum {
    private static Object lock = new Object();
    private static volatile int num = 0;
    public class PrintThread implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                while (num < 100){
                    System.out.println(Thread.currentThread().getName() + "打印：" + ++num);
                    lock.notifyAll();
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    @Test
    public void test(){java
        new Thread(new PrintThread(),"thread1").start();
        new Thread(new PrintThread(),"thread2").start();
    }
}
```

# 14 链表反转

```Java
public class Reverse {
    //单链表
    static class ListNode{
        int val;
        ListNode next;
        public ListNode(int val){
            this.val=val;
        }
    }
    //翻转方法
    public static ListNode reverse(ListNode head){
        //指定当前节点的前驱
        ListNode pre=null;
        //当前节点
        ListNode cur=head;
        //当前节点的后继
        ListNode next=null;
        //因为这里每次执行后都是将next赋给了cur，所以需要判断cur
        while (cur!=null){
            //保存当前节点的后继
            next=cur.next;
            //将当前节点后继改成前驱，这也是翻转最重要的一步，头结点的后继应该为空
            cur.next=pre;
            //依次向后移动一个单位，执行完成后，pre指的是翻转前最后的节点，也就是翻转后的头结点
            pre=cur;
            cur=next;
        }
        return pre;
    }
    public static void main(String[] args) {
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        ListNode node4 = new ListNode(4);
        ListNode node5 = new ListNode(5);
        ListNode node6 = new ListNode(6);
        node1.next=node2;
        node2.next=node3;
        node3.next=node4;
        node4.next=node5;
        node5.next=node6;
        ListNode reverse = reverse(node1);
        while (reverse!=null){
            System.out.println(reverse.val);
            reverse=reverse.next;
        }
    }
```

# 15 linux 常用操作命令

https://www.cnblogs.com/banjinbaijiu/p/9140460.html

# 16 Mybatis mapper动态代理的原理详解

https://www.cnblogs.com/hopeofthevillage/p/11384848.html



# 17 线程隔离 ThreadLocal

https://www.cnblogs.com/beatIteWeNerverGiveUp/p/5950440.html

# 18 Dubbo原理简述一：RPC原理和Netty通信原理

https://blog.csdn.net/qq_33404395/article/details/86497215

# 19 最全面的阿里多线程面试题，你能回答几个？

https://blog.csdn.net/qq_20499001/article/details/99978083

# 21 Java中的常量类缓存机制

https://cloud.tencent.com/developer/article/1451236

# 22 同步锁实现，与Lock的区别 1.8中的优化，可重入锁，偏向锁

https://www.cnblogs.com/my376908915/p/6757833.html

https://www.cnblogs.com/linghu-java/p/8944784.html

https://www.pianshen.com/article/3799167501/

https://www.pianshen.com/article/3799167501/

# 23 HashMap中链表转红黑树条件 长度8，达到阀值

https://www.pianshen.com/article/8845315407/

# 24 cureentHashMaP实现；1.8后的优化



https://www.jianshu.com/p/e694f1e868ec

# 25 数据库索引

# 26 JVM，类加载，java->jvm中，垃圾回收器



# 27 zk协议，选举



# 28 Redis集群



# 29 链表

https://blog.csdn.net/weixin_41445507/article/details/89074868

https://blog.csdn.net/qq_41027326/article/details/79787434

https://www.jianshu.com/p/81a6ed0abeb8

https://blog.csdn.net/qq_41966475/article/details/105217145

https://blog.csdn.net/qq_15720911/article/details/76945226?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control



https://blog.csdn.net/u010442302/article/details/51864187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control



# 30 osi七层模型从下到上分别为：

1、物理层：建立、维bai护、断开物理连接。

TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。

2、数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。

将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。

3、网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。

协议有：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP。



4、传输层：定义传输数据的协议端口号，以及流控和差错校验。

协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层。

5、会话层：建立、管理、终止会话。

对应主机进程，指本地主机与远程主机正在进行的会话。

6、表示层：数据的表示、安全、压缩。

格式有JPEG、ASCll、DECOIC、加密格式等。

7、应用层：网络服务与最终用户的一个接口。

协议有：HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP

https://zhidao.baidu.com/question/571359857.html

# 31 详细说一下一个浏览器发出去一个请求都经过了那些步骤

https://www.cnblogs.com/xsj1/p/11202277.html

https://www.cnblogs.com/windy-xmwh/p/9296253.html

https://blog.csdn.net/wnx_52055/article/details/88353441?utm_medium=distribute.pc_relevant.none-task-blog-title-15&spm=1001.2101.3001.4242

# 32 阿里面试题

https://www.jb51.net/it/667282.html

# 33 中移面试

https://www.nowcoder.com/discuss/303907?type=2&order=3&pos=5&page=1&channel=-2&source_id=discuss_tag



# 34 java 灰度值，二值化，查找，极值

https://www.cnblogs.com/zjut-jiangnan/p/3619288.html

# 35 HashMap的链表数据结构是用来解决什么问题的

https://www.cnblogs.com/weigy/p/12572569.html

解决哈希冲突。

1、JDK1.7的HashMap是由数组+链表构成的，新增一个数通过哈希算法，计算出对应存放在数组的某个位置，如果这个位置已经存在数据了，也就是说存在了哈希冲突，这时候JDK1.7就将新增的数和原来的数构成一个链表放在数组这个位置，后面冲突的数依次都放入链表中。
2、通常解决哈希冲突有两种办法，上面所说的通过链表的形式称为链地址法；
还有一种方法称为开放地址法，也就是说如果存在哈希冲突了，那么将新增的值在用一个新的哈希算法算出所存的位置插入，但是这还会构成二次冲突，三次冲突.....

3、JDK1.8的HashMap是由数组+链表+红黑树构成，
当链表长度超过8会自动转换成红黑树，红黑树节点个数小于6，又自动转换为链表。这是为了提高检索效率（红黑树检索效率明显是高于链表的）

# 36 哈希冲突及四种解决方法

https://www.cnblogs.com/higerMan/p/11907117.html

# 37 深入分析AQS实现原理

AQS是一个用来构建锁和同步器的框架

**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中**

https://segmentfault.com/a/1190000017372067

# 38  CycliBarriar 和 CountdownLatch 有什么区别？

CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：

- CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。
- 调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；
- CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；
- CountDownLatch是不能复用的，而CyclicLatch是可以复用的。

# 39 2019年BAT常问面试题汇总：JVM+微服务+多线程+锁+高并发性能

https://cloud.tencent.com/developer/article/1557077

# 40 Volatile可见性、缓存一致性协议、指令重排、内存屏障 、总线风暴

https://blog.csdn.net/sinat_42483341/article/details/106592833

https://www.cnblogs.com/amei0/p/8378625.html

https://www.cnblogs.com/baizhanshi/p/6422926.html

https://blog.csdn.net/li12127878/article/details/101001128

https://www.cnblogs.com/jiagoujishu/p/13744544.html

# 41 mysql索引

https://www.cnblogs.com/bypp/p/7755307.html

https://blog.csdn.net/u013308490/article/details/83001060

https://www.jianshu.com/p/d90f6b028d0e

https://baijiahao.baidu.com/s?id=1661980510559470562&wfr=spider&for=pc

# 42 count(1) 和count(*) 的区别

count(1)与count(*)比较： 

如果你的数据表没有主键，那么count(1)比count(*)快 

如果有主键的话，那主键（联合主键）作为count的条件也比count(*)要快 

如果你的表只有一个字段的话那count(*)就是最快的啦 

count(*) count(1) 两者比较。主要还是要count(1)所相对应的数据字段。 

如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 

因为count(*),自动会优化指定到那一个字段。所以没必要去count(?)，用count(*),sql会帮你完成优化的

 count详解：

count(*)将返回表格中所有存在的行的总数包括值为null的行，然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）.

distinct 列名,得到的结果将是除去值为null和重复数据后的结果

https://blog.csdn.net/szstephenzhou/article/details/8446481

https://blog.csdn.net/haijiege/article/details/85006780

# 43 行锁和表锁的区别

https://www.cnblogs.com/ngrzr/p/11906710.html

## 43.1 行锁

1、支持的存储引擎：Innodb；

2、InnoDB行锁是通过给索引上的索引项加锁来实现的，意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

3、适用场景：有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用

4、特点：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

5、分析：show status like 'innodb_row_lock%';分析系统上行锁的争夺情况如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。

## 43.2 表锁

1、支持的存储引擎：Innodb、MYIsam

2、适用场景：以查询为主，只有少量按索引条件更新数据的应用

3、特点：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

4、两种模式：

 • 表共享读锁

 • 表独占写锁

5、对两张表显示加锁、解锁

 Lock tables orders read local, order_detail read local;

 Select sum(total) from orders;

 Select sum(subtotal) from order_detail;

 Unlock tables;

6、MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁

# 44 mysql普通索引与唯一索引区别

https://blog.csdn.net/qq_36918149/article/details/96704830

# 45 InnoDB中的页合并与分裂

https://blog.csdn.net/qq_35045184/article/details/104346594

# 46 对B+树，B树，红黑树的理解

https://www.cnblogs.com/myseries/p/10662710.html

**区别有以下两点：**

1. B+树中只有叶子节点会带有指向记录的指针，而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
2. B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

**B+树的优点：**

1. **非叶子节点不会带上指向记录的指针，这样，一个块中可以容纳更多的索引项，**一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
2. 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。**具体的来讲，如何想扫描一次所有数据，对于b+树来说，可以从因为他们的叶子结点是连在一起的，所以可以横向的遍历过去。而对于b-树来说，就这能中序遍历了。**

**B树的优点：**
对于在内部节点的数据，可直接得到，不必根据叶子节点来定位

**红黑树的规则：**
1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点

###### 红黑树 和 b+树的用途有什么区别？

1. 红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。
2. B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。

# 47可达性算法分析中根节点有哪些

https://blog.csdn.net/u012501054/article/details/97773322

那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：

(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

(2). 方法区中的类静态属性引用的对象。

(3). 方法区中常量引用的对象。

(4). 本地方法栈中JNI(Native方法)引用的对象。

# 48 CMS 和G1 的区别

https://www.jianshu.com/p/ab54489f5d71

### 区别一： 使用范围不一样

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
 G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

### 区别二： STW的时间

CMS收集器以最小的停顿时间为目标的收集器。

G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

### 区别三： 垃圾碎片

CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片

G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 区别四： 垃圾回收的过程不一样

![img](https:////upload-images.jianshu.io/upload_images/10819106-3ada1f0a939574ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)



# 49 JVM 配置常用参数和常用 GC 调优策略

https://blog.csdn.net/An1090239782/article/details/95098712

**GC 调优策略**

策略 1：

> 将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC
> 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

策略 2：

> 大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的
> full
> gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收老说简直就是噩梦）。-XX:PretenureSizeThreshold
> 可以设置直接进入老年代的对象大小。

策略 3：

> 合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低
> full gc 发生的频率。

策略 4：

> 设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。

策略5：

> 注意：如果满足下面的指标，则一般不需要进行 GC 优化：
> MinorGC 执行时间不到50ms；
> Minor GC 执行不频繁，约10秒一次；
> Full GC 执行时间不到1s；
> Full GC 执行频率不算频繁，不低于10分钟1次。

# 50 排查Java高CPU占用及内存飙升原因

https://www.cnblogs.com/cnndevelop/p/11091813.html

https://blog.csdn.net/qq_34944965/article/details/81107419

https://blog.csdn.net/weixin_30323961/article/details/95639909

1、先通过top命令找到消耗cpu很高的进程id假设是123

2、执行top -p 123单独监控该进程

3、在第2步的监控界面输入H，获取当前进程下的所有线程信息

4、找到消耗cpu特别高的线程编号，假设是123

5、执行jstack 123456对当前的进程做dump，输出所有的线程信息

6 将第4步得到的线程编号11354转成16进制是0x7b

7 根据第6步得到的0x7b在第5步的线程信息里面去找对应线程内容

8 解读线程信息，定位具体代码位置

# 51 排查Java 逃逸分析

https://blog.csdn.net/hollis_chuang/article/details/80922794

https://www.cnblogs.com/javastack/p/11023044.html

