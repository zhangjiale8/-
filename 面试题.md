# 1. == 与equals的区别？equals原理

== 是地址比较

equals是值比较

基本数据类型用==

基本类型的包装类重写了equals方法

 Object类中的equals方法和“==”是一样的，没有区别，即俩个对象的比较是比较他们的栈内存中存储的内存地址。而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==不同”，他们比较的是值是不是相等。所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法

1.  ==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
2. ==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较
3. ==指引用是否相同， equals()指的是值是否相同

 如果两个对象相同，那么它们的hashCode值一定要相同。也告诉我们重写equals方法，一定要重写hashCode方法，也就是说hashCode值要和类中的成员变量挂上钩，对象相同–>成员变量相同—->hashCode值一定相同。 
如果两个对象的hashCode相同，它们并不一定相同，这里的对象相同指的是用eqauls方法比较

# 2. 线程池原理

https://www.jianshu.com/p/125ccf0046f3



# 3. 五种线程池的分类和作用

https://www.cnblogs.com/vince66/p/9325638.html

# 4.阻塞队列原理

https://www.jb51.net/article/117204.htm

# 5. spring声明式事务原理

https://blog.csdn.net/sinat_34341162/article/details/84192023

#  6. 动态代理原理

https://www.jianshu.com/p/85d181d7d09a



# 7 SpringBoot自动装配原理

https://blog.csdn.net/Dongguabai/article/details/80865599

# 8 java注解

https://blog.csdn.net/yuzongtao/article/details/83306182

# 9 千万级数据量主键，单据号生成

https://bbs.csdn.net/topics/260075534

https://blog.csdn.net/jiabeis/article/details/80999498

雪花算法

https://blog.csdn.net/u012516166/article/details/76559526

# 10 数据库索引

https://www.cnblogs.com/phpdragon/p/8231533.html

https://blog.csdn.net/tongdanping/article/details/79878302

主键索引、唯一索引、普通索引、全文索引（FULLTEXT，不能使用like）、组合索引

```sql
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```



# 11 生产者消费者模式

https://www.cnblogs.com/luego/p/12048857.html

https://blog.csdn.net/sanyuesan0000/article/details/52996586

java实现：

https://blog.csdn.net/shadowcw/article/details/82352829



# 12 设计模式

https://www.javazhiyin.com/zx/sjms/page/6



# 13 两个线程交替打印1-100

```java
public class PrintNum {
    private static Object lock = new Object();
    private static volatile int num = 0;
    public class PrintThread implements Runnable{
        @Override
        public void run() {
            synchronized (lock){
                while (num < 100){
                    System.out.println(Thread.currentThread().getName() + "打印：" + ++num);
                    lock.notifyAll();
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    @Test
    public void test(){java
        new Thread(new PrintThread(),"thread1").start();
        new Thread(new PrintThread(),"thread2").start();
    }
}
```

# 14 链表反转

```Java
public class Reverse {
    //单链表
    static class ListNode{
        int val;
        ListNode next;
        public ListNode(int val){
            this.val=val;
        }
    }
    //翻转方法
    public static ListNode reverse(ListNode head){
        //指定当前节点的前驱
        ListNode pre=null;
        //当前节点
        ListNode cur=head;
        //当前节点的后继
        ListNode next=null;
        //因为这里每次执行后都是将next赋给了cur，所以需要判断cur
        while (cur!=null){
            //保存当前节点的后继
            next=cur.next;
            //将当前节点后继改成前驱，这也是翻转最重要的一步，头结点的后继应该为空
            cur.next=pre;
            //依次向后移动一个单位，执行完成后，pre指的是翻转前最后的节点，也就是翻转后的头结点
            pre=cur;
            cur=next;
        }
        return pre;
    }
    public static void main(String[] args) {
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        ListNode node4 = new ListNode(4);
        ListNode node5 = new ListNode(5);
        ListNode node6 = new ListNode(6);
        node1.next=node2;
        node2.next=node3;
        node3.next=node4;
        node4.next=node5;
        node5.next=node6;
        ListNode reverse = reverse(node1);
        while (reverse!=null){
            System.out.println(reverse.val);
            reverse=reverse.next;
        }
    }
```

# 15 linux 常用操作命令

https://www.cnblogs.com/banjinbaijiu/p/9140460.html

# 16 Mybatis mapper动态代理的原理详解

https://www.cnblogs.com/hopeofthevillage/p/11384848.html



# 17 线程隔离 ThreadLocal

https://www.cnblogs.com/beatIteWeNerverGiveUp/p/5950440.html

# 18 Dubbo原理简述一：RPC原理和Netty通信原理

https://blog.csdn.net/qq_33404395/article/details/86497215

# 19 最全面的阿里多线程面试题，你能回答几个？

https://blog.csdn.net/qq_20499001/article/details/99978083

# 21 Java中的常量类缓存机制

https://cloud.tencent.com/developer/article/1451236

# 22 同步锁实现，与Lock的区别 1.8中的优化，可重入锁，偏向锁

https://www.cnblogs.com/my376908915/p/6757833.html

https://www.cnblogs.com/linghu-java/p/8944784.html

https://www.pianshen.com/article/3799167501/

https://www.pianshen.com/article/3799167501/

# 23 HashMap中链表转红黑树条件 长度8，达到阀值

https://www.pianshen.com/article/8845315407/

# 24 cureentHashMaP实现；1.8后的优化



https://www.jianshu.com/p/e694f1e868ec

# 25 数据库索引

# 26 JVM，类加载，java->jvm中，垃圾回收器



# 27 zk协议，选举



# 28 Redis集群



# 29 链表

https://blog.csdn.net/weixin_41445507/article/details/89074868

https://blog.csdn.net/qq_41027326/article/details/79787434

https://www.jianshu.com/p/81a6ed0abeb8

https://blog.csdn.net/qq_41966475/article/details/105217145

https://blog.csdn.net/qq_15720911/article/details/76945226?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control



https://blog.csdn.net/u010442302/article/details/51864187?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control



# 30 osi七层模型从下到上分别为：

1、物理层：建立、维bai护、断开物理连接。

TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。

2、数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。

将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。

3、网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。

协议有：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP。



4、传输层：定义传输数据的协议端口号，以及流控和差错校验。

协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层。

5、会话层：建立、管理、终止会话。

对应主机进程，指本地主机与远程主机正在进行的会话。

6、表示层：数据的表示、安全、压缩。

格式有JPEG、ASCll、DECOIC、加密格式等。

7、应用层：网络服务与最终用户的一个接口。

协议有：HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP

https://zhidao.baidu.com/question/571359857.html

# 31 详细说一下一个浏览器发出去一个请求都经过了那些步骤

https://www.cnblogs.com/xsj1/p/11202277.html

https://www.cnblogs.com/windy-xmwh/p/9296253.html

https://blog.csdn.net/wnx_52055/article/details/88353441?utm_medium=distribute.pc_relevant.none-task-blog-title-15&spm=1001.2101.3001.4242

# 32 阿里面试题

https://www.jb51.net/it/667282.html

# 33 中移面试

https://www.nowcoder.com/discuss/303907?type=2&order=3&pos=5&page=1&channel=-2&source_id=discuss_tag



# 34 java 灰度值，二值化，查找，极值

https://www.cnblogs.com/zjut-jiangnan/p/3619288.html

# 35 HashMap的链表数据结构是用来解决什么问题的

https://www.cnblogs.com/weigy/p/12572569.html

解决哈希冲突。

1、JDK1.7的HashMap是由数组+链表构成的，新增一个数通过哈希算法，计算出对应存放在数组的某个位置，如果这个位置已经存在数据了，也就是说存在了哈希冲突，这时候JDK1.7就将新增的数和原来的数构成一个链表放在数组这个位置，后面冲突的数依次都放入链表中。
2、通常解决哈希冲突有两种办法，上面所说的通过链表的形式称为链地址法；
还有一种方法称为开放地址法，也就是说如果存在哈希冲突了，那么将新增的值在用一个新的哈希算法算出所存的位置插入，但是这还会构成二次冲突，三次冲突.....

3、JDK1.8的HashMap是由数组+链表+红黑树构成，
当链表长度超过8会自动转换成红黑树，红黑树节点个数小于6，又自动转换为链表。这是为了提高检索效率（红黑树检索效率明显是高于链表的）

# 36 哈希冲突及四种解决方法

https://www.cnblogs.com/higerMan/p/11907117.html

# 37 深入分析AQS实现原理

AQS是一个用来构建锁和同步器的框架

**AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中**

https://segmentfault.com/a/1190000017372067

# 38  CycliBarriar 和 CountdownLatch 有什么区别？

CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：

- CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。
- 调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；
- CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；
- CountDownLatch是不能复用的，而CyclicLatch是可以复用的。

# 39 2019年BAT常问面试题汇总：JVM+微服务+多线程+锁+高并发性能

https://cloud.tencent.com/developer/article/1557077

# 40 Volatile可见性、缓存一致性协议、指令重排、内存屏障 、总线风暴

https://blog.csdn.net/sinat_42483341/article/details/106592833

https://www.cnblogs.com/amei0/p/8378625.html

https://www.cnblogs.com/baizhanshi/p/6422926.html

https://blog.csdn.net/li12127878/article/details/101001128

https://www.cnblogs.com/jiagoujishu/p/13744544.html

# 41 mysql索引

https://www.cnblogs.com/bypp/p/7755307.html

https://blog.csdn.net/u013308490/article/details/83001060

https://www.jianshu.com/p/d90f6b028d0e

https://baijiahao.baidu.com/s?id=1661980510559470562&wfr=spider&for=pc

# 42 count(1) 和count(*) 的区别

count(1)与count(*)比较： 

如果你的数据表没有主键，那么count(1)比count(*)快 

如果有主键的话，那主键（联合主键）作为count的条件也比count(*)要快 

如果你的表只有一个字段的话那count(*)就是最快的啦 

count(*) count(1) 两者比较。主要还是要count(1)所相对应的数据字段。 

如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 

因为count(*),自动会优化指定到那一个字段。所以没必要去count(?)，用count(*),sql会帮你完成优化的

 count详解：

count(*)将返回表格中所有存在的行的总数包括值为null的行，然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）.

distinct 列名,得到的结果将是除去值为null和重复数据后的结果

https://blog.csdn.net/szstephenzhou/article/details/8446481

https://blog.csdn.net/haijiege/article/details/85006780

# 43 行锁和表锁的区别

https://www.cnblogs.com/ngrzr/p/11906710.html

## 43.1 行锁

1、支持的存储引擎：Innodb；

2、InnoDB行锁是通过给索引上的索引项加锁来实现的，意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

3、适用场景：有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用

4、特点：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

5、分析：show status like 'innodb_row_lock%';分析系统上行锁的争夺情况如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。

## 43.2 表锁

1、支持的存储引擎：Innodb、MYIsam

2、适用场景：以查询为主，只有少量按索引条件更新数据的应用

3、特点：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

4、两种模式：

 • 表共享读锁

 • 表独占写锁

5、对两张表显示加锁、解锁

 Lock tables orders read local, order_detail read local;

 Select sum(total) from orders;

 Select sum(subtotal) from order_detail;

 Unlock tables;

6、MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁

# 44 mysql普通索引与唯一索引区别

https://blog.csdn.net/qq_36918149/article/details/96704830

# 45 InnoDB中的页合并与分裂

https://blog.csdn.net/qq_35045184/article/details/104346594

# 46 对B+树，B树，红黑树的理解

https://www.cnblogs.com/myseries/p/10662710.html

**区别有以下两点：**

1. B+树中只有叶子节点会带有指向记录的指针，而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
2. B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

**B+树的优点：**

1. **非叶子节点不会带上指向记录的指针，这样，一个块中可以容纳更多的索引项，**一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
2. 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。**具体的来讲，如何想扫描一次所有数据，对于b+树来说，可以从因为他们的叶子结点是连在一起的，所以可以横向的遍历过去。而对于b-树来说，就这能中序遍历了。**

**B树的优点：**
对于在内部节点的数据，可直接得到，不必根据叶子节点来定位

**红黑树的规则：**
1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点

###### 红黑树 和 b+树的用途有什么区别？

1. 红黑树多用在内部排序，即全放在内存中的，STL的map和set的内部实现就是红黑树。
2. B+树多用于外存上时，B+也被成为一个磁盘友好的数据结构。

# 47可达性算法分析中根节点有哪些

https://blog.csdn.net/u012501054/article/details/97773322

那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：

(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

(2). 方法区中的类静态属性引用的对象。

(3). 方法区中常量引用的对象。

(4). 本地方法栈中JNI(Native方法)引用的对象。

# 48 CMS 和G1 的区别

https://www.jianshu.com/p/ab54489f5d71

### 区别一： 使用范围不一样

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
 G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

### 区别二： STW的时间

CMS收集器以最小的停顿时间为目标的收集器。

G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

### 区别三： 垃圾碎片

CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片

G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 区别四： 垃圾回收的过程不一样

![img](https:////upload-images.jianshu.io/upload_images/10819106-3ada1f0a939574ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/672/format/webp)



# 49 JVM 配置常用参数和常用 GC 调优策略

https://blog.csdn.net/An1090239782/article/details/95098712

**GC 调优策略**

策略 1：

> 将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC
> 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

策略 2：

> 大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的
> full
> gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收老说简直就是噩梦）。-XX:PretenureSizeThreshold
> 可以设置直接进入老年代的对象大小。

策略 3：

> 合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低
> full gc 发生的频率。

策略 4：

> 设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。

策略5：

> 注意：如果满足下面的指标，则一般不需要进行 GC 优化：
> MinorGC 执行时间不到50ms；
> Minor GC 执行不频繁，约10秒一次；
> Full GC 执行时间不到1s；
> Full GC 执行频率不算频繁，不低于10分钟1次。

# 50 排查Java高CPU占用及内存飙升原因

https://www.cnblogs.com/cnndevelop/p/11091813.html

https://blog.csdn.net/qq_34944965/article/details/81107419

https://blog.csdn.net/weixin_30323961/article/details/95639909

1、先通过top命令找到消耗cpu很高的进程id假设是123

2、执行top -p 123单独监控该进程

3、在第2步的监控界面输入H，获取当前进程下的所有线程信息

4、找到消耗cpu特别高的线程编号，假设是123

5、执行jstack 123456对当前的进程做dump，输出所有的线程信息

6 将第4步得到的线程编号11354转成16进制是0x7b

7 根据第6步得到的0x7b在第5步的线程信息里面去找对应线程内容

8 解读线程信息，定位具体代码位置

# 51 排查Java 逃逸分析

https://blog.csdn.net/hollis_chuang/article/details/80922794

https://www.cnblogs.com/javastack/p/11023044.html

# 52 Dubbo服务暴露与注册

https://my.oschina.net/zhangxufeng/blog/3062739

# 51 常量缓存池

同上21

# 52 BigDecimal精度会丢失吗？

https://www.cnblogs.com/lzghyh/p/12951080.html

### BigDecimal精度也丢失

**我们在使用BigDecimal时，使用它的BigDecimal(String)构造器创建对象才有意义**

### 正确运用BigDecimal

划重点！！！

**在使用BigDecimal时，一定要用它的BigDecimal(String)构造器创建对象。**

BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。

方法中的参数也必须是BigDecimal的对象，由刚才我们所罗列的API也可看出。可以参看相应的API；

在一般开发过程中，我们数据库中存储的数据都是float和double类型的。在进行拿来拿去运算的时候还需要不断的转化，建议自己搞一个工具类

# 53 如何读取比机器内存大的文件（内存4G，文件 8G，读取大文件） ？

https://blog.csdn.net/wohu1104/article/details/104708892

1.使用生成器 yield 逐行读取到内存

2.使用 pandas 的 read_csv 函数

https://www.cnblogs.com/firstdream/p/5536013.html

https://blog.csdn.net/u011774997/article/details/106761437

问：使用内存文件映射 MappedByteBuffer 读超大文件会有什么问题吗？
答：这种方式存在一个致命问题就是依然没法读取超大文件（大于 Integer.MAX_VALUE），因为 FileChannel 的 map 方法中 size 参数会有大小限制，源码中发现该参数值大于 Integer.MAX_VALUE 时会直接抛出 IllegalArgumentException(“Size exceeds Integer.MAX_VALUE”)异常，所以对于特别大的文件其依然不适合。

本质上是由于 java.nio.MappedByteBuffer 直接继承自 java.nio.ByteBuffer，而 ByteBuffer 的索引是 int 类型的，所以 MappedByteBuffer 也只能最大索引到 Integer.MAX_VALUE 的位置，所以 FileChannel 的 map 方法会做参数合法性检查

# 54 IO、NIO和AIO的区别

https://www.cnblogs.com/aspirant/p/8630283.html

https://blog.csdn.net/lee9289/article/details/82260267

IO和NIO的区别：其本质就是阻塞和非阻塞的区别。

阻塞概念：应用程序在获取网络数据的时候，如果网络传输数据很慢，那么久一直等着，知道传输完毕为止。
非阻塞概念：应用程序直接可以获取已经准备就绪好的数据，无需等待。(从操作系统缓冲区中直接读取已经缓冲完毕的数据，不用阻塞等待数据缓冲完毕，可以在这段时间中做其他事)

同步和异步的区别：

同步：应用程序会直接参与IO读写操作哦，并且应用程序会直接阻塞到某个方法上，知道数据准备就绪；或者采用轮询的策略实时检查数据的就绪状态，如果就绪则获取数据。
异步：所有的IO读写交给操作系统处理，于应用程序没有直接关系，程序不需要关心IO读写，当操作系统完成了IO读写时，会给应用程序发送通知，应用程序直接拿走数据即可。

同步说的是server服务端的执行方式（面向操作系统，异步：操作系统已经完成加载的过程）
阻塞说的是具体技术，接收数据的方式、状态（io、nio）

AIO：
在NIO基础上引入了异步通道的概念，病提供了异步文件异步套接字通道的实现。AIO不需要通过多路复用器对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO变成模型。

https://www.cnblogs.com/zgghb/p/7021316.html

# 55 IO（BIO），NIO，AIO的深度解析和区别

https://blog.csdn.net/madongyu1259892936/article/details/79311671

![d87a237af3ba4080f598a536e5dcede2.png](https://www.pianshen.com/images/754/d87a237af3ba4080f598a536e5dcede2.png)

http://hccm.rongsoft.com/article/2020/09/221604392741/

NIO详解：https://www.jianshu.com/p/ad16183b88cf

https://ifeve.com/overview/

# 56 为什么阿里Java规约禁止使用Java内置Executors创建线程池？

 https://www.cnblogs.com/ibigboy/p/11298004.html

**参数的意义：**

1.corePoolSize 指定了线程池里的线程数量，核心线程池大小

2.maximumPoolSize 指定了线程池里的最大线程数量

3.keepAliveTime 当线程池线程数量大于corePoolSize时候，多出来的空闲线程，多长时间会被销毁。

4.unit 时间单位。TimeUnit

5.workQueue 任务队列，用于存放提交但是尚未被执行的任务。

　　我们可以选择如下几种：

- ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。[
  ](http://cmsblogs.com/?p=2381)
- LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。
- SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作，反之亦然。[
  ](http://cmsblogs.com/?p=2418)
- PriorityBlockingQueue：具有优先级别的阻塞队列。[
  ](http://cmsblogs.com/?p=2407)

6.threadFactory 线程工厂，用于创建线程，一般可以用默认的

7.handler 拒绝策略，所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。

　　什么时候拒绝？当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务，该任务会交给RejectedExecutionHandler 处理。

　　线程池提供了四种拒绝策略：

1. AbortPolicy：直接抛出异常，默认策略；
2. CallerRunsPolicy：用调用者所在的线程来执行任务；
3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
4. DiscardPolicy：直接丢弃任务；

 \-------

阿里规约之所以强制要求手动创建线程池，也是和这些参数有关。具体为什么不允许，规约是这么说的：

线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

Executor提供的四个静态方法创建线程池，但是阿里规约却并不建议使用它。

> Executors各个方法的弊端：
> 1）newFixedThreadPool和newSingleThreadExecutor:
>   主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。
> 2）newCachedThreadPool和newScheduledThreadPool:
>   主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM

# 57 sleep与 wait区别

线程baisleep 和wait 的区别：
1、这两个方法来自不同的类分du别是zhiThread和Object
2、最主要是sleep方法没有释放锁，dao而wait方法释放了锁，使得其他zhuan线程可以使用同步控制块或者方法。
3、wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围）
4、sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
5、sleep是Thread类的静态方法。sleep的作用是让线程休眠制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者

# 58 Java面试题之notify和notifyAll的区别

### 锁池：

　　假设线程A已经拥有对象锁，线程B、C想要获取锁就会被阻塞，进入一个地方去等待锁的等待，这个地方就是该对象的锁池；

### 等待池：

　　假设线程A调用某个对象的wait方法，线程A就会释放该对象锁，同时线程A进入该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁。 

### notify和notifyAll的区别：

1、notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；

2、notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；

# 59 唤醒指定线程

https://zhuanlan.zhihu.com/p/67271820

## 给队列加一个锁lock，然后创建两个Condition，一个是full，处理队列满的情况；另一个是empty，处理队列空的情况。
操作流程是这样的：
生产者：
1、获得锁
2、检查队列是否满，如果满则等待full condition，直到被消费者唤醒
3、将元素加入队列
4、notify empty condition，唤醒一个消费者
5、释放锁

消费者：
1、获得锁
2、检查队列是否空，如果空则等待empty condition，直到被生产者唤醒
3、从队列中取出一个元素
4、notify full condition，唤醒一个生产者
5、释放锁。

牢记一点，Condition**不是锁**，不存在“锁定”Condition的情况

## 使用Java6引入的**LockSupport**这个类。

# 60 factorybean和beanfactory的区别

https://www.cnblogs.com/aspirant/p/9082858.html

# 61 BeanFactory和ApplicationContext的区别

https://blog.csdn.net/pythias_/article/details/82752881

# 62 Spring注解@Resource和@Autowired区别对比详解

https://www.jb51.net/article/169300.htm

@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入

@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用

@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型

# 63 AOP 实现原理

动态代理

https://www.jianshu.com/p/22cf46235d75

# 64 JDK动态代理与cglib动态代理区别

https://www.cnblogs.com/bigmonkeys/p/7823268.html

一、简单来说：

　　**JDK动态代理只能对实现了接口的类生成代理，而不能针对类**

　　**CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）**

二、Spring在选择用JDK还是CGLiB的依据：

  (1)当Bean实现接口时，Spring就会用JDK的动态代理

  (2)当Bean没有实现接口时，Spring使用CGlib是实现

　 (3)可以强制使用CGlib（在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>）

三、CGlib比JDK快？

　 (1)使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。

　 (2)在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右



https://blog.csdn.net/c_royi/article/details/86539846

# 65 慢SQL优化

https://blog.csdn.net/qq_35571554/article/details/82800463

直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句

得到如下结果： 显示结果分析：  

​          table | type | possible_keys | key |key_len | ref | rows | Extra EXPLAIN列的解释：      

​          table         显示这一行的数据是关于哪张表的      

​         ***\*type\****         这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL 

​          ***\*rows\****        显示需要扫描行数

​          ***\*key\****          使用的索引

# 66 linux 常用命令

https://blog.csdn.net/luansj/article/details/97272672

# 67 linux 快速查看某进程的pid

pgrep -l xxxx

Linux top 命令快速入门：https://www.linuxprobe.com/linux-top-easy.html

解决的办法是：

(1) 先用pgrep [str] 命令进行模糊匹配，找到匹配该特征串的进程ID；

(2) 其次根据进程ID显示指定的进程信息，ps --pid [pid]；

(3) 因为查找出来的进程ID需要被作为参数传递给ps命令，故使用xargs命令，通过管道符号连接；

(4) 最后显示进程详细信息，需要加上-u参数。

最终命令形如:

pgrep java | xargs ps -u --pid

# 68 Mybatis事务管理的两种方式

https://blog.csdn.net/u011109589/article/details/80491507

https://www.cnblogs.com/Irving88/p/13354190.html?utm_source=tuicool

Mybatis管理事务是分为两种方式:

(1)使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交

(2)使用MANAGED的事务管理机制，这种机制mybatis自身不会去实现事务管理，而是让程序的容器（JBOSS,WebLogic）来实现对事务的管理

Transaction接口中有两个实现类：JdbcTransaction和ManagedTransaction。

（1）JdbcTransaction
JdbcTransaction直接使用JDBC的提交和回滚事务管理机制。它依赖与从dataSource中取得的连接connection来管理transaction的作用域，connection对象的获取被延迟到调用getConnection()方法。如果autoCommit设置为on，开启状态的话，它会忽略commit和rollback。

（2）ManagedTransaction

查看这个类，可知其中的commit方法和rollback方法没有具体实现。ManagedTransaction是让容器来管理事务Transaction的整个生命周期，使用ManagedTransaction的commit和rollback功能不会对事务有任何影响，它没有具体实现，它将事务管理权交给容器来实现

# 69 spring的作用

AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP后，公共服务（比如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。

　　IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反过来的JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straightconstruction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。

　　Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了Spring，只要用JavaBean属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。

　　Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理bean 的方式，如图 1 所示。

　　组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：

　　核心容器：核心容器提供 Spring框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory使用控制反转（IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。

　　Spring 上下文：Spring 上下文是一个配置文件，向 Spring框架提供上下文信息。Spring上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。

　　Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了Spring框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。

　　Spring DAO：JDBCDAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。SpringDAO的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。

　　Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM的对象关系工具，其中包括JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和DAO异常层次结构。

　　Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。

　　Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC实现。通过策略接口，MVC框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括JSP、Velocity、Tiles、iText 和 POI。

　　spring 框架的功能可以用在任何 J2EE服务器中，大多数功能也适用于不受管理的环境。Spring的核心要点是：支持不绑定到特定 J2EE服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web或EJB）、独立应用程序、测试环境之间重用

# 70 spring bean的生命周期

https://www.cnblogs.com/zrtqsk/p/3735273.html

![image-20201125144523344](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20201125144523344.png)

# 71 Spring解决bean的循环依赖问题？为何需要三级缓存,而不是两级缓存?

https://blog.csdn.net/weixin_42228338/article/details/97163101

https://blog.csdn.net/u010597819/article/details/107595103?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control

熟悉spring框架的同学应该都知道spring单例使用的三级缓存，简单回顾下哪三级缓存，源码类：DefaultSingletonBeanRegistry

1. 一级缓存：singletonObjects
2. 二级缓存：earlySingletonObjects
3. 三级缓存：singletonFactories

直接使用一级缓存不可以吗？

## 一级缓存，也就是直接将单例bean缓存至singletonObjects，去除其他缓存。设想下面这个场景

1. 创建单例A
2. 初始化单例A（单例A强依赖单例B），注入单例B
3. 从工厂中获取单例B发现不存在，则创建
4. 创建单例B
5. 初始化单例B（单例B强依赖单例A），注入单例A
6. 从工厂中获取单例A发现不存在（因为正在创建中），则创建？？？？？？

没错，问题来了，循环依赖，死循环，直接凉凉。

## 直接使用二级缓存不可以吗？

对于直接使用一级缓存的问题已经暴露，如何解决？那么有同学就要问了，那我在创建单例A时就直接将单例A放入缓存中不可以吗？这样不就解决了循环依赖问题？是的，这样处理是可以的。但是我们如何判断从工厂中获取的一个单例初始化完成了？对单例的所有依赖注入的属性进行一次判空来判断？依赖注入的实例是否完成了初始化？使用工厂中的单例还要各种判空是不是很恶心？增加二级缓存岂不快哉
使用二级缓存：earlySingletonObjects+singletonObjects

1. 创建单例A
2. 单例A放入二级缓存：earlySingletonObjects
3. 初始化单例A（单例A强依赖单例B），注入单例B
4. 从工厂中获取单例B发现不存在，则创建
5. 创建单例B
6. 单例B放入二级缓存：earlySingletonObjects
7. 初始化单例B（单例B强依赖单例A），注入单例A
8. 从一级缓存singletonObjects获取单例A，存在则返回，不存在继续查询二级缓存：earlySingletonObjects，如果不存在则创建单例A（此时发现循环依赖抛出异常），但是看到前面已经缓存在二级缓存中
9. 注入单例A（可能是未完成初始化的单例A）完成
10. 初始化单例B完成，移除二级缓存中的单例B，缓存单例B至一级缓存，返回单例B
11. 注入单例B完成
12. 初始化单例A完成，移除二级缓存中的单例A，缓存单例A至一级缓存，返回单例A

可以看到我们之前的问题全部迎刃而解，只要从工厂中的一级缓存中获取的单例均是完成了初始化，并且依赖注入的实例也均是完成了初始化，只是如果是循环依赖场景，可能得到的依赖注入时未完成初始化的，即某些依赖注入属性可能为null，例如：@Value注入的一些值。

## 为什么spring单例要使用三级缓存？

那么二级缓存已经解决了问题，为什么还要引入三级缓存呢？设想下，如果我想要在读取二级缓存：earlySingletonObjects对象时统一增加一些日志或者其他处理动作，如何解决？在读取earlySingletonObjects对象实例后，对实例进行回调某些接口方法？当然没问题，可以看到spring对于非单例bean也采用该方法来处理前置、后置动作的回调

https://www.cnblogs.com/shoshana-kong/p/10890136.html	

# 72 Redis五种数据结构

![img](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621163930814-1395015700.png)

# 73 Redis跳跃表

https://www.cnblogs.com/buptleida/p/12838880.html

https://blog.csdn.net/wei_gg/article/details/92407489

**跳跃表**是一种有序数据结构，它通过每个结点中维持多个指向其它结点的指针，从而达到快速访问结点的目的。

我们平时熟知的链表，查找效率为O(N)。跳表在链表的基础上，每个结点中维护了很多指向其它结点的指针，大大缩短时间复杂度。可以实现时间复杂度平均O(logN)，最坏O(N)。后文会有具体的分析和计算。

一个跳跃表示意图：
![image](http://qiniu.debrisflow.cn/20200506skipList.jpg)
由左至右依次是，跳跃表结构结点(存储跳表信息)、头结点、连续的跳表结点

https://www.cnblogs.com/qixinbo/p/9682721.html

# 74 redis的qps

https://www.cnblogs.com/chencanjian/p/10026215.html

https://blog.csdn.net/u011439839/article/details/94412239

测算Redis处理实际生产请求的QPS/TPS

## Benchmark工具

redis发布版本中自带了redis-benchmark性能测试工具;

示例： 
使用50个并发连接，发出100000个请求，每个请求的数据为2kb， 
测试host为127.0.0.1 端口为6379的redis服务器性能

1.单机的redis一般是支持上万甚至几万，具体的性能取决于数据操作的复杂性，如果仅仅是简单的kv操作的话，可以达到数万，如果是运行复杂的lua脚本的话，就可能只能到一万左右
2.缓存一般是用来支撑读的高并发，一般比较少用来支撑读的操作，一般读的操作是比较频繁的，甚至达到几万几十万，但是写的操作每秒才几千，这就需要读写分离了；
架构一般做成主从架构：
master：负责写数据，master数据写入之后，会将数据同步至slave中
slave：负责读数据，多个slave
这种的架构的有点在于可以水平扩容，比较灵活

https://www.jianshu.com/p/6a04fd821165

## Redis为什么这么快

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
 2、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU；
 3、使用多路I/O复用模型，非阻塞IO；
 4、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

## 多路 I/O 复用模型

多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

## 单线程redis和多核CPU

单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行

# 74 Redis集群详解

https://blog.csdn.net/miss1181248983/article/details/90056960

* 主从模式 
* Sentinel模式 
* Cluster模式

## 主从模式

* 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库
* 从数据库一般都是只读的，并且接收主数据库同步过来的数据
* 一个master可以拥有多个slave，但是一个slave只能对应一个master
* slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来
* master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务
* master挂了以后，不会在slave节点中重新选一个master

### 工作机制：

当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。

复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。

### 安全设置：

当master节点设置密码后

* 客户端访问master需要密码
* 启动slave需要密码，在配置文件中配置即可
* 客户端访问slave不需要密码

### 缺点：

从上面可以看出，master节点在主从模式中唯一，若master挂掉，则redis无法对外提供写服务

## Sentinel模式

主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel应运而生。

sentinel中文含义为哨兵，顾名思义，它的作用就是监控redis集群的运行状况，特点如下：

* sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义

* 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master

* 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据

* sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群

* 多sentinel配置的时候，sentinel之间也会自动监控

* 当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心

* 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis

* sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了

### 工作机制：

* 每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 

* 如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。 

* 如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态

* 当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线 

* 在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 

* 当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 

* 若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；
  若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除

## Cluster模式

​	sentinel模式基本可以满足一般生产的需求，具备高可用性。但是当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。

​	cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。

使用集群，只需要将redis配置文件中的`cluster-enable`配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。

### cluster集群特点：

* 多个redis节点网络互联，数据共享
* 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用
* 不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，
  并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为
* 支持在线增加、删除节点
* 客户端可以连接任何一个主节点进行读写

# 75 分析redis key大小的几种方法

redis被用作缓存时，有时我们希望了解key的大小分布，或者想知道哪些key占的空间比较大。本文提供了几种方法。

## bigKeys

这是redis-cli自带的一个命令。对整个redis进行扫描，寻找较大的key。例：

```
redis-cli -h b.redis -p 1959 --bigkeys
```

说明：

1. 该命令使用scan方式对key进行统计，所以使用时无需担心对redis造成阻塞。
2. 输出大概分为两部分，summary之上的部分，只是显示了扫描的过程。summary部分给出了每种数据结构中最大的Key。
3. 统计出的最大key只有string类型是以字节长度为衡量标准的。list,set,zset等都是以元素个数作为衡量标准，不能说明其占的内存就一定多。所以，如果你的Key主要以string类型存在，这种方法就比较适合

## debug object key

redis的命令，可以查看某个key序列化后的长度。
例：

```
连接上redis后执行如下命令

b.redis:1959> hmset myhash k1 v1 k2 v2 k3 v3
OK
b.redis:1959> debug object myhash
Value at:0x7f005c6920a0 refcount:1 encoding:ziplist serializedlength:36 lru:3341677 lru_seconds_idle:2
123456
```

关于输出的项的说明：

- Value at：key的内存地址
- refcount：引用次数
- encoding：编码类型
- serializedlength：序列化长度
- lru_seconds_idle：空闲时间

## 总结

- 如果想粗略的看下最大key, 可以使用bigKeys。
- 如果查询的key不多，key的压缩比又没有明显差异，可以使用debug object key

# 76 谈谈redis的热key问题如何解决

https://www.cnblogs.com/rjzheng/p/10874537.html

​	所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。
​	那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用

### 怎么发现热key

*方法一:凭借业务经验，进行预估哪些是热key*
其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。
*方法二:在客户端进行收集*
这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。
*方法三:在Proxy层做收集*
有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。
![img](https://img2018.cnblogs.com/blog/725429/201905/725429-20190516112209464-1290077151.png)
*方法四:用redis自带命令*
(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如`redis-faina`。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。
(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。
*方法五:自己抓包评估*
Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。

以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？

### 如何解决

目前业内的方案有两种
*(1)利用二级缓存*
比如利用`ehcache`，或者一个`HashMap`都可以。在你发现热key以后，把热key加载到系统的JVM中。
针对这种热key请求，会直接从jvm中取，而不会走到redis层。
假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。
现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。
*(2)备份热key*
这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。
假设redis的集群数量为N，步骤如下图所示
![img](https://img2018.cnblogs.com/blog/725429/201905/725429-20190516112222759-656135438.png)

业内怎么做的。其实只有两步
(1)监控热key
(2)通知系统做处理

# 77 缓存阶段性总结2：（时效性要求很高的数据）高并发场景下的缓存+数据库双写不一致问题分析与解决方案设计

https://blog.csdn.net/weixin_40663800/article/details/90674454

**解决：时效性要求很高的数据，库存，采取的是数据库+缓存双写的技术方案，也解决双写的一致性的问题**

最经典的缓存+数据库读写的模式，cache aside pattern

- （1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应
- （2）更新的时候，先删除缓存，然后再更新数据库

# 78 dubbo服务暴露与引用过程

https://blog.csdn.net/qq_33404395/article/details/86498060

dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=”-1”）：

- 设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()。ServiceBean实现了如果InitializingBean接口，重写了afterPropertySet()方法。如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。
- 没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务。（ServiceBean实现了ApplicationListener接口）

但是不管延迟与否，都是使用ServiceConfig的export()方法进行服务的暴露。使用export初始化的时候会将Bean对象转换成URL格式，所有Bean属性转换成URL的参数

### 暴露流程

- 首先将服务的实现封装成一个Invoker，Invoker中封装了服务的实现类。
- 将Invoker封装成Exporter，并缓存起来，缓存里使用Invoker的url作为key。
- 服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）

敖丙：

阿里面试：dubbo的服务引用过程 ： https://www.cnblogs.com/aobing/p/13630666.html

Dubbo系列之服务暴露过程 : https://www.cnblogs.com/aobing/p/13703750.html

# 79 Dubbo的负载均衡策略

Random LoadBalance

> **随机**，按权重设置随机概率。
> 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

## RoundRobin LoadBalance

> **轮询**，按公约后的权重设置轮询比率。
> 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

## LeastActive LoadBalance

> **最少活跃调用数**，相同活跃数的随机，活跃数指调用前后计数差。
> 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

## ConsistentHash LoadBalance

> **一致性 Hash**，相同参数的请求总是发到同一提供者。
> 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
> 算法参见： [http://en.wikipedia.org/wiki/Consistent_hashing](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Consistent_hashing)
> 缺省只对第一个参数 Hash，如果要修改，请配置 `<dubbo:parameter key="hash.arguments" value="0,1" />`
> 缺省用 160 份虚拟节点，如果要修改，请配置 `<dubbo:parameter key="hash.nodes" value="320" />`

# 80 Dubbo集群容错机制

源码： https://www.dazhuanlan.com/2020/01/10/5e17f8508b894/

**Failover Cluster：失败重试**

当服务消费方调用服务提供者失败后自动切换到其他服务提供者服务器进行重试。这通常用于读操作或者具有幂等的写操作，需要注意的是重试会带来更长延迟。可通过 retries="2" 来设置重试次数（不含第一次）。

接口级别配置重试次数方法 <dubbo:reference retries="2" /> ，如上配置当服务消费方调用服务失败后，会再重试两次，也就是说最多会做三次调用，这里的配置对该接口的所有方法生效。当然你也可以针对某个方法配置重试次数如下

**Failfast Cluster：快速失败**

当服务消费方调用服务提供者失败后，立即报错，也就是只调用一次。通常这种模式用于非幂等性的写操作。

**Failsafe Cluster：失败安全**

当服务消费者调用服务出现异常时，直接忽略异常。这种模式通常用于写入审计日志等操作。

**Failback Cluster：失败自动恢复**

当服务消费端用服务出现异常后，在后台记录失败的请求，并按照一定的策略后期再进行重试。这种模式通常用于消息通知操作。

**Forking Cluster：并行调用**

当消费方调用一个接口方法后，Dubbo Client会并行调用多个服务提供者的服务，只要一个成功即返回。这种模式通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。

**Broadcast Cluster：广播调用**

当消费者调用一个接口方法后，Dubbo Client会逐个调用所有服务提供者，任意一台调用异常则这次调用就标志失败。这种模式通常用于通知所有提供者更新缓存或日志等本地资源信息。

如上，Dubbo本身提供了丰富的集群容错模式，但是如果您有定制化需求，可以根据Dubbo提供的扩展接口Cluster进行定制。在后面的消费方启动流程章节会讲解何时/如何使用的集群容错。

