# 1.多线程中，共享的变量为何在main()里必须用final修饰

多线程中，共享的变量为何在main()里必须用final修饰? 代码如下，两个线程修改同一个list，为何在main里声明list的时候一定要用final。

```java
public class TwoThreadsOneListCurrModi{
    public static void main(String[] args){
        final List<String> list = Collections.synchronizedList(new ArrayList<String>());

        for (int i =0 ; i<20;i++)
        list.add(String.valueOf(i));
        Thread t1 = new Thread(new Runnable(){

            @Override
            public void run()
            {
                synchronized(list){
                	do sth with the list.
                }
            }
        });

        Thread t2 = new Thread(new Runnable(){
            @Override
            public void run()
            {
                synchronized(list){
                	do sth with the list.
                }
            }
        });
        t1.start();
        t2.start();
    }
}
```

若是用匿名类的方式，就不用final来修饰list，不明白为什么。

```java
public class TwoThreadsOneListCurrModi2
{
    public static void main(String[] args)
    {
        final List<String> list = Collections.synchronizedList(new ArrayList<String>());
        initialize list;

        Thread t1 = new WorkThread(list);
        Thread t2 = new WorkThread(list);
        t1.start();
        t2.start();
        }
    }
    class WorkThread extends Thread{
        List<String> list;
        public void run(){
        	do sth with list
        }
        Work1(List<String> list)
        {
            this.list = list; 
        }
    }   
}
```

首先纠正提问者的提问，贴出来的第一段代码属于匿名内部类，第二端代码不属于匿名内部类。

回答你的问题，为什么在匿名内部类中引用外部对象要加final修饰符呢，因为，在匿名内部类中引用的外部对象受到外部线程的作用域的制约有其特定的生命周期，以线程为例，当外部的变量生命周期已经完结之后，内部的线程还在运行，怎么样解决这个外部生命周期已经结束而在内部却需要继续使用呢，这个时候就需要在外部变量中添加final修饰符，其实内部匿名类使用的这个变量就是外部变量的一个“复制品”，即使外部变量生命周期已经结束，内部的“复制品“依然可用。

[网络搜索](https://www.baidu.com/s?wd=网络搜索&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的答案如下：
为什么匿名内部类参数必须为final类型
1) 从程序设计语言的理论上:局部内部类(即:定义在方法中的内部类),由于本身就是在方法内部(可出现在形式参数定义处或者方法体处),因而访问方法中的局部变量(形式参数或局部变量)是天经地义的.是很自然的
2) 为什么JAVA中要加上一条限制:只能访问final型的局部变量?
3) [JAVA语言](https://www.baidu.com/s?wd=JAVA语言&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的编译程序的设计者当然全实现:局部内部类能访问方法中的所有的局部变量(因为:从理论上这是很自然的要求),但是:编译技术是无法实现的或代价极高.
4) 困难在何处?到底难在哪儿?
局部变量的生命周期与局部内部类的对象的生命周期的不一致性!
5) 设方法f被调用,从而在它的调用栈中生成了变量i,此时产生了一个局部内部类对象inner_object,它访问了该局部变量i .当方法f()运行结束后,局部变量i就已死亡了,不存在了.但:局部内部类对象inner_object还可能 一直存在(只能没有人再引用该对象时,它才会死亡),它不会随着方法f()运行结束死亡.这时:出现了一个"荒唐"结果:局部内部类对象 inner_object要访问一个已不存在的局部变量i!
6) 如何才能实现?当变量是final时,通过将final局部变量"复制"一份,复制品直接作为局部内部中的数据成员.这样:当局部内部类访问局部变量 时,其实真正访问的是这个局部变量的"复制品"(即:这个复制品就代表了那个局部变量).因此:当运行栈中的真正的局部变量死亡时,局部内部类对象仍可以 访问局部变量(其实访问的是"复制品"),给人的感觉:好像是局部变量的"生命期"延长了.
那么:核心的问题是:怎么才能使得:访问"复制品"与访问真正的原始的局部变量,其语义效果是一样的呢?
当变量是final时,若是基本数据类型,由于其值不变,因而:其复制品与原始的量是一样.语义效果相同.(若:不是final,就无法保证:复制品与原始变量保持一致了,因为:在方法中改的是原始变量,而局部内部类中改的是复制品)

当 变量是final时,若是引用类型,由于其引用值不变(即:永远指向同一个对象),因而:其复制品与原始的[引用变量](https://www.baidu.com/s?wd=引用变量&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)一样,永远指向同一个对象(由于是 final,从而保证:只能指向这个对象,再不能指向其它对象),达到:局部内部类中访问的复制品与方法代码中访问的原始对象,永远都是同一个即:语义效 果是一样的.否则:当方法中改原始变量,而局部内部类中改复制品时,就无法保证:复制品与原始变量保持一致了(因此:它们原本就应该是同一个变量.)

一句话:这个规定是一种无可奈何.也说明:程序设计语言的设计是受到实现技术的限制的.这就是一例. 因为:我就看到不少人都持这种观点:设计与想法是最重要的,实现的技术是无关紧要的,只要你作出设计与规定,都能实现.