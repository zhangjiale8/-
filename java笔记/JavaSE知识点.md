# 1.java 概述

```
1991 年Sun公司的James Gosling等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器；
1994年将Oak语言更名为Java；
```

# 2.Java的三种技术架构（3个分支）

```
JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发；
JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；
JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序；
```

# 3. Java结构

```
JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。
JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。
```

# 4.Java环境变量配置

```
让java jdk\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。
```

## 4.1 环境变量的配置

### 4.1.1 永久配置方式（系统变量）

JAVA_HOME=%安装路径%\Java\jdk  

path=%JAVA_HOME%\bin

### 4.1.2 临时配置方式（用户变量）

set path=%path%;C:\Program Files\Java\jdk\bin

```
特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。
```

## 4.2 classpath的配置

### 4.2.1 永久配置方式（系统变量）

classpath=.;c:\;e:\

### 4.2.2 临时配置方式（用户变量）

set classpath=.;c:\;e:\

```
注意：
在定义classpath环境变量时，需要注意的情况

如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；
如果指定了classpath，那么会在指定的目录下查找要运行的类文件。

还会在当前目录找吗？两种情况：

1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。
2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。

一般不指定分号，如果没有在指定目录下找不到要运行的类文件，就报错，这样可以调试程序
```

# 5.javac命令和java命令

java分两部分：一个是编译，一个是运行

## 5.1 javac命令

```
负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。
```

## 5.2 java命令

```
负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.
```

```
注意： 一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.
```

# 6.关键字与标识符

## 6.1 关键字

其实就是某种语言赋予了特殊含义的单词

```java
abstract, assert,
boolean, break, byte,
case, catch, char, class, const, continue,
default, do, double,
else, enum, extends,
final, finally, float, for,
goto,
if, implements, import, instanceof, int, interface,
long,
native, new,
package, private, protected, public,
return,
short, static, strictfp, super, switch, synchronized,
this, throw, throws, transient, try,
void, volatile,
while
```

```
其中保留关键字为：goto, const
Java1.2添加的关键字：strictfp
Java1.4添加的关键字：assert
Java5.0添加的关键字：enum
```

## 6.2 Java保留字

```java
byValue,
cast, const,
false, future,
generic, goto
inner,
null，
operator, outer,
rest,
true,
var
```

## 6.3 标示符

在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ；

```
注意：
1），数字不可以开头。
2），不可以使用关键字。
```

## 6.4 常量与变量

### 6.4.1 常量

在程序中的不会变化的数据。

### 6.4.2 变量

内存中的一个存储空间，用于存储常量数据。

方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。

```
特点：变量空间可以重复使用。
什么时候定义变量？
只要是数据不确定的时候，就定义变量。
```

#### 6.4.2.1 变量空间的开辟需要什么要素呢？

```
1.这个空间要存储什么数据？数据类型。
2.这个空间叫什么名字啊？变量名称。
3.这个空间的第一次的数据是什么？ 变量的初始化值
```

#### 6.4.2.2 变量的作用域和生存期

```
变量的作用域：
    作用域从变量定义的位置开始，到该变量所在的那对大括号结束；
生命周期：
    变量从定义的位置开始就在内存中活了；
    变量到达它所在的作用域的时候就在内存中消失了；
```

# 7.数据类型

## 7.1 基本数据类型

```java
byte、short、int、long、float、double、char、boolean
```

# 7.2 引用数据类型

数组、类、接口

```
级别从低到高：byte,char,short(这三个平级)-->int-->float-->long-->double
自动类型转换：从低级别到高级别，系统自动转的；
强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；
```

# 8.运算符

## 8.1 算术运算符

```
+ - * / % ++,--
```

```
注：
%:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。
+:连接符。
```

## 8.2 赋值运算符

```
=  += -= *= /= %=
```

## 8.3 比较运算符

```
> 、 < 、 >= 、 <= 、== 、 !=
```

```
注意：
> 、 < 、 >= 、 <= 只支持左右两边操作数是数值类型
== 、 != 两边的操作数既可以是数值类型，也可以是引用类型
```

```
特点：该运算符的特点是：运算完的结果，要么是true，要么是false。
```

## 8.4 逻辑运算符

```
&  |  ^  !   &&   ||
```

```
注意：
逻辑运算符除了 !  外都是用于连接两个boolean类型表达式。
&: 只有两边都为true结果是true。否则就是false。
|:只要两边都为false结果是false，否则就是true
^:异或和或有点不一样。 两边结果一样，就为false。两边结果不一样，就为true.
& 和 &&区别：
& ：无论左边结果是什么，右边都参与运算。
&&:短路与，如果左边为false，那么右边不参数与运算。
| 和|| 区别：
|：两边都运算。
||：短路或，如果左边为true，那么右边不参与运算。
```

## 8.5 条件运算符（三元运算符）

```
 ? :
语法形式：布尔表达式 ？ 表达式1 ：表达式2
运算过程：如果布尔表达式的值为 true ，则返回 表达式1 的值，否则返回 表达式2 的值
```

## 8.6 位运算符

```
&  |  ^
<<  >>   >>>(无符号右移)
```

```java
练习1：对两个变量的数据进行互换。不需要第三方变量。
int a  = 3,b = 5;-->b = 3,a = 5;
a = a + b; a = 8;
b = a - b; b = 3;
a = a - b; a = 5;
a = a ^ b;//
b = a ^ b;//b = a ^ b ^ b = a
a = a ^ b;//a = a ^ b ^ a = b;

练习2：高效的算出 2*8
2*8 = 2<<3;
```

# 9.条件与循环语句

If 、 switch 、 do while 、  while 、 for

## 9.1 条件语句

### 9.1.1.当判断固定个数的值的时候，可以使用if，也可以使用switch。但是建议使用switch，效率相对较高。

```
switch(变量){

 case 值:要执行的语句;break;

 …

 default:要执行的语句;

}

工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了，就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；
```

```
注：
 1）：break是可以省略的，如果省略了就一直执行到遇到break为止；
 2）：switch 后面的小括号中的变量应该是byte,char,short,int，String五种类型中的一种；
 3）：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。
```

### 9.1.2 当判断数据范围，获取判断运算结果boolean类型时，需要使用if。

## 9.2 循环语句

当某些语句需要执行很多次时，就用循环结构。

while和for可以进行互换。

```
while和for区别在于：
如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。
```

## 9.3 break 

作用于switch ，和循环语句，用于跳出，或者称为结束。

```
break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。
```

## 9.4 continue

只作用于循环结构，继续循环用的。

```
作用：
结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。
```

# 10.函 数

为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。

```
java中的函数的定义格式：
修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){
执行语句；
return 返回值；
}
当函数没有具体的返回值时，返回的返回值类型用void关键字表示。
如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。
```

```
return的作用：
结束函数。结束功能。
```

```
如何定义一个函数？
函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：
1）：明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。
2）：在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&参数个数)。
```

```
函数的作用：
1）：用于定义功能。
2）：用于封装代码提高代码的复用性。
注意：函数中只能调用函数，不能定义函数。
```

```
主函数：
1）：保证该类的独立运行。
2）：因为它是程序的入口。
3）：因为它在被jvm调用。
```

```
函数定义名称是为什么呢？
1）：为了对该功能进行标示，方便于调用。
2）：为了通过名称就可以明确函数的功能，为了增加代码的阅读性
```

## 10.1  重写(Override)

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。

```
方法的重写规则：
1）：参数列表必须完全与被重写方法的相同；
2）：返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）；
3）：访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
4）：父类的成员方法只能被它的子类重写。
5）：声明为final的方法不能被重写。
6）：声明为static的方法不能被重写，但是能够被再次声明。
7）：子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
8）：子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
9）：重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
10）：构造方法不能被重写。
11）：如果不能继承一个方法，则不能重写这个方法
```

## 10.2 重载(Overload)

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

```
重载规则:
1）：被重载的方法必须改变参数列表(参数个数或类型不一样)；
2）：被重载的方法可以改变返回类型；
3）：被重载的方法可以改变访问修饰符；
4）：被重载的方法可以声明新的或更广的检查异常；
5）：方法能够在同一个类中或者在一个子类中被重载。
6）：无法以返回值类型作为重载函数的区分标准。
```

```
重载的定义是：
在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。
如何区分重载：
当函数同名时，只看参数列表。和返回值类型没关系。
```

## 10.3 重写与重载之间的区别

| 区别点   | 重载方法 | 重写方法                                       |
| :------- | :------- | :--------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                   |
| 返回类型 | 可以修改 | 一定不能修改                                   |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

```
1)：方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
2)：方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
3)：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。
```

# 11.数组

用于存储同一类型数据的一个容器。

可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。

数组是用来存储固定大小的同类型元素。

```
1）：数组名代表的是连续空间的首地址
2）：通过首地址可以依次访问数组所有元素
3）：元素在数组中的排序叫做下标从零开始
```

```
如何在java中表现一个数组呢？两种表现形式：
1）：元素类型[] 变量名 = new 元素类型[元素的个数]；
2）：元素类型[] 变量名 = {元素1，元素2...}；
元素类型[] 变量名 = new 元素类型[]{元素1，元素2...}；
```

```java
//二分查找法。必须有前提：数组中的元素要有序。
public static int halfSeach_2(int[] arr,int key){
    int min,max,mid;//定义最小，最大，中间数
    min = 0;//最小为0
    max = arr.length-1;// 最大为数组的长度-1
    mid = (max+min)>>1; //(max+min)/2;//中间数为最大加最小除以2
    while(arr[mid]!=key){//如果数组中間值不等于key
        if(key>arr[mid]){//如果key>中間值
            min = mid + 1;
        }
        else if(key<arr[mid])
            max = mid - 1;
        if(max<min)
            return -1;
        mid = (max+min)>>1;
    }
    return mid;
}
```

## 11.1 Arrays 类

java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。

```
具有以下功能：
1）：给数组赋值：通过 fill 方法。
2）：对数组排序：通过 sort 方法,按升序。
3）：比较数组：通过 equals 方法比较数组中元素值是否相等。
4）：查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。
```

具体说明请查看下表：

| 序号 | 方法和说明                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |
| 2    | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |
| 3    | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |
| 4    | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |

```
java分了5片内存。(寄存器、本地方法区、方法区、栈、堆）。
1）栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；只要数据运算完成所在的区域结束，该数据就会被释放。
2）堆：用于存储数组和对象，也就是实体。
啥是实体啊？就是用于封装多个数据的。
1）：每一个实体都有内存首地址值。
2）：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。
3）：垃圾回收机制
```

# 12. 面向对象

```
特点：
1：将复杂的事情简单化。
2：面向对象将以前的过程中的执行者，变成了指挥者。
3：面向对象这种思想是符合现在人们思考习惯的一种思想。
```

```
过程和对象在我们的程序中是如何体现的呢？
过程其实就是函数；对象是将函数等一些内容进行了封装。
```

## 12.1 匿名对象

```
匿名对象：没有名字的对象
new Car();  //匿名对象其实就是定义对象的简写格式。
```

```java
Car c = new Car();
c.run();
//用匿名对象来书写以上代码：
new Car().run();
```

### 12.1.1 匿名对象使用方法

#### 12.1.1.1  当对象对方法仅进行一次调用的时候，就可以简化成匿名对象

```java
//如一个 对象需要进行调用方法2次，用匿名对象的
new Car().run()
new Car().run()
//这是2个对象分别调用了run()，不是一个对象调用了多方法。
```

#### 12.1.1.2 匿名对象可以作为实际参数进行传递

```java
public static void show(Car c)
{
//......
}
show(new Car());
```

### 12.1.2 匿名对象内存分析

![](java相关资源\匿名对象内存分析.jpg)

### 12.1.3 如何区分匿名对象和匿名类

```java
//匿名对象：
Person类：
new Person(); //这就是一个匿名对象
//匿名类：
new Person(){
String name;
};//这就是一个匿名类
```

```
总结：
1）：匿名对象还是一个对象，它必须有已经写好的成员变量、属性、方法。
2）：匿名类，在声明它的对象的时候，才对它进行代码的构造（封装它的成员变量、属性、方法等）
3）：匿名对象：一个对象只需要使用一次的时候，通常使用匿名对象
4）：匿名类：比如我们需要一个监听类，并且在实例化这个监听类的时候才需要实现这个监听类内部的方法，那么使用匿名类就最方便了。
```

## 12.2 成员变量与成员函数

在类中定义其实都称之为成员。成员有两种：

1）：**成员变量**：其实对应的就是事物的属性。

2）：**成员函数**：其实对应的就是事物的行为。

所以，其实**定义类，就是在定义成员变量和成员函数**。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。

k