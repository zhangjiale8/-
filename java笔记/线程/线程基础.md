# 一、并行与并发

```
并行：多个CPU实例或是多台机器同时执行一段处理逻辑，是真正的同时。
```

```
并发：通过CPU调度算法，让用户看上去同时执行，实际上从CPU操作层面并不是真正的同时。
并发往往需要公共的资源，对公共资源的处理和线程之间的协调是并发的难点重点。
```

## 1.1 并发与并行比较：

 	 如果你想要一个程序运行的更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。并发是用于多处理器编程的基本工具。为了使程序运行得更快，你必须学习如何利用这些额外的处理器，而这正是并发赋予你的能力。
  如果你有一台多处理器的机器，那么就可以在这些处理器之间分部多个任务，从而可以极大的提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每一个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。
  
  **但是，并发通常是提高运行在单处理器上的程序的性能**。
  
  因为，在单处理器上运行的并发程序开销应该比改程序的所有部分都顺序执行的开销大，因为其中增加了所谓的**上下文切换的代价（从一个任务切换到另一个任务）**。表面上看，将程序的所有部分当作单个的任务运行好像是开销更小一点，并且可以节省上下文切换的代价。
  使得这个问题变得有些不同的是**阻塞**。如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或现场**阻塞**了。如果没有并发，则整个程序都将停止下来，直到外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。事实上，从性能的角度看，如果没有任务阻塞，那么在单处理器上使用并发就没有任何意义。
  在单处理器系统中的性能提高的常见实例是**事件驱动的编程**。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。这也是在Android系统中不允许子线程总访问UI的原因，在Android中的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。那为什么系统不对UI控件的访问加上锁机制呢？原因有两个：其一，加上锁会让UI访问的逻辑变的复杂；其二，锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。所以在Android系统中最简单而且高效的方法就是采用单线程模型来处理UI操作。

## 1.2 进程和线程

​	实现并发最直接的方式是在操作系统级别使用**进程**。进程是运行在它**自己的地址空间内**的自包容的程序。

​	多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个（进程）程序，尽管这使得每个进程看起来在其执行过程中都是歇歇停停。进程被操作系统互相隔开，因此不会彼此干涉，这使得用进程编程相对容易一些。

​	与此相反，像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编程编写多线程程序最基本的困难在于，**协调不同线程驱动的任务之间对这些资源的使用，以便使得这些资源不会同时被多个任务访问**。

# 二、基础概念

## 2.1 线程状态图

![](线程状态图.jpg)

### 2.1.1 线程5种状态

1.新建（ New）：线程对象被创建时，它只会短暂的处于这种状态。此时它已经分配了必须的系统资源，并执行了初始化。

例如：Thread  thread = new Thread();

2.就绪（Runnable）：称为"可执行状态"。线程对象被创建后，其他线程调用了该对象的start()方法，从而启动该线程。

例如：thread.start();

处于就绪状态的线程，随时可能被CPU调度执行。

3.运行（Running）：线程获取CPU权限进行执行。

```
注意：
线程只能从就绪状态进入运行状态
```

 4.阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

```
阻塞的三种情况：
（1）等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。
（2）同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。
（3）其他阻塞：通过调用线程的sleep()或者发出I/O请求时，线程会进入阻塞状态。当sleep()状态超时、join()等待线程终止或超时。或是I/O处理完毕时，线程重新转入就绪状态。
```

5.死亡（Dead）：线程执行完或者因为异常退出run()方法，该线程结束生命周期。

## 2.2 关键字与关键函数

线程的5种状态（新建、就绪、运行、阻塞、死亡）涉及的内容包括Object类，Thread类和synchronized关键字。

```
在Object类中，定义了wait()、notify()、notifyAll()等一系列休眠/唤醒函数。
```

```
在Thread类中，定义了一系列线程操作函数，例如：sleep()休眠函数、interrupt()中断函数、getName()获取线程名称等。
```

```
synchronized关键字：synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。
```

# 三、常用的实现多线程的两种方式

## 3.1 概述

常用的实现多线程的两种方式：Thread和Runnable。之所以说是"常用"，是因为**在java5后可以通过java.until.concurrent包中的线程池来实现多线程**。（[线程进阶.md]( [线程进阶.md](线程进阶.md) )）

Runnable是一个接口，该接口包含了一个**run()**方法，Runnable具有更好的扩展性。

Thread是一个类，**Thread本身是实现了Runnable接口**。

此外，**Runnable还可以用于"资源共享"。即，多个线程都是基于某个Runnable对象创建的，它们会共享Runnable对象上的资源**。

## 3.2 实现多线程实例

### 3.2.1 定义任务（Runnable）

线程可以驱动任务，因此需要一种描述任务的方式。

在Java中用Runnable接口来提供，需要定义任务，只需要实现Runnable接口并编写run()方法，使得该任务可以执行命令。

```java
package com.zjl.javase.thread;

public class RunnableTest {
	public static void main(String[] args) {
		class MyRunnable implements Runnable{
			private int tickets = 10;
			public void run() {
				for (int i = 0; i < 20; i++) {
					if(this.tickets > 0) {
						System.out.println(Thread.currentThread().getName()+ "卖票：	   			tickets"+this.tickets --);
					}
				}
				
			}
			
		}
        // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！这说明它们是共享了	MyRunnable接口的。
		MyRunnable runnable = new MyRunnable();
		Thread t1 = new Thread(runnable);
		Thread t2 = new Thread(runnable);
		Thread t3 = new Thread(runnable);
		t1.start();
		t2.start();
		t3.start();
		
	}
}

运行结果：

Thread-1卖票：tickets10
Thread-1卖票：tickets7
Thread-1卖票：tickets6
Thread-1卖票：tickets5
Thread-1卖票：tickets4
Thread-1卖票：tickets3
Thread-1卖票：tickets2
Thread-1卖票：tickets1
Thread-2卖票：tickets9
Thread-0卖票：tickets8

```

### 3.2.2 继承Thread类

将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。

```java
package com.zjl.javase.thread;

public class ThreadTest {
	public static void main(String[] args) {
		class MyThread extends Thread {
			private int tickets = 10;
			@Override
			public void run() {
				for (int i = 0; i < 20; i++) {
					if(this.tickets > 0){
						System.out.println(this.getName()+"买票：ticket"+this.tickets--);
					}
				}
			}
			
		}
		
		// 启动3个线程t1,t2,t3；每个线程各卖10张票！
        // 和上面的结果对比，并揣摩 “Runnable还可以用于“资源共享”。即，多个线程都是基于某个Runnable对象建立的，它们会共享Runnable对象上的资源”这句话。
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();
		MyThread t3 = new MyThread();
		t1.start();
		t2.start();
		t3.start();
	}
}


运行结果：
Thread-0买票：ticket10
Thread-1买票：ticket10
Thread-0买票：ticket9
Thread-0买票：ticket8
Thread-0买票：ticket7
Thread-0买票：ticket6
Thread-2买票：ticket10
Thread-2买票：ticket9
Thread-2买票：ticket8
Thread-2买票：ticket7
Thread-2买票：ticket6
Thread-2买票：ticket5
Thread-2买票：ticket4
Thread-2买票：ticket3
Thread-2买票：ticket2
Thread-2买票：ticket1
Thread-1买票：ticket9
Thread-1买票：ticket8
Thread-1买票：ticket7
Thread-1买票：ticket6
Thread-1买票：ticket5
Thread-1买票：ticket4
Thread-1买票：ticket3
Thread-1买票：ticket2
Thread-1买票：ticket1
Thread-0买票：ticket5
Thread-0买票：ticket4
Thread-0买票：ticket3
Thread-0买票：ticket2
Thread-0买票：ticket1
```

# 四、synchronized 关键字

## 4.1 概述

​	**synchronized关键字是为了解决共享资源竞争的问题**，共享资源一般是**以对象形式存在的内存片段**，但也可以是文件、输入/输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问的这个资源的方法标记为synchronized。如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。所有对象都自动含有**单一的锁（也称为监视器）**。当在对象上调用其任意synchronized方法的时候，对象都被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。 
  **在Java中，每个对象有且仅有一个同步锁**。这也意味着，**同步锁是依赖于对象而存在的**。当我们调用某个对象的synchronized方法时，就获得了该对象的同步锁，不同线程对同步锁的访问是互斥的。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为**互斥量（mutex）**。


## 4.2 synchronized 基本原则和实例

### 4.2.1 基本原则

synchronized的基本原则总结如下：

**第一条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**该synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

**第二条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**仍然可以访问**该对象**的**非同步代码块**。

**第三条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**其他的synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

### 4.2.2 实例

**第一条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**该synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

```
package com.zjl.javase.thread;

public class RunnableTest {
	public static void main(String[] args) {
		class MyRunnable implements Runnable{
			private int tickets = 5;
			public void run() {
				synchronized(this){
					for (int i = 0; i < 5; i++) {
							try {
								Thread.sleep(100);
								System.out.println(Thread.currentThread().getName()+" loop " +i);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
					}
				}
				
			}
			
		}
		
		Runnable runnable = new MyRunnable();
		Thread t1 = new Thread(runnable,"t1");
		Thread t2 = new Thread(runnable,"t2");
		t1.start();
		t2.start();
	}
}

运行结果：
t1 loop 0
t1 loop 1
t1 loop 2
t1 loop 3
t1 loop 4
t2 loop 0
t2 loop 1
t2 loop 2
t2 loop 3
t2 loop 4
```

总结：

**run()**方法中存在**synchronized(this)**代码块，而且t1和t2都是基于**MyRunnable**这个**Runnable对象**创建的线程。这意味着，我们能可以将synchronized(this)中的this看作是**MyRunnable这个Runnable对象**；因此，线程t1和t2共享"MyRunnable对象的同步锁"。所以当一个线程运行时，另外一个线程必须等待**正在运行的线程**释放**MyRunnable的同步锁**之后才能运行。

```java
package com.zjl.javase.thread;

public class ThreadTest {
	public static void main(String[] args) {
		class MyThread extends Thread {
			
			public MyThread(String name) {
				super(name);
			}

			@Override
			public void run() {
				synchronized(this) {
					for (int i = 0; i < 10; i++) {
						try {
							Thread.sleep(100);
							System.out.println(Thread.currentThread().getName() +" loop "+i);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
				}
			}
			
		}
		
		MyThread t1 = new MyThread("t1");
		MyThread t2 = new MyThread("t2");
		t1.start();
		t2.start();
	}
}

运行结果：
t2 loop 0
t1 loop 0
t2 loop 1
t1 loop 1
t1 loop 2
t2 loop 2
t1 loop 3
t2 loop 3
t1 loop 4
t2 loop 4
t1 loop 5
t2 loop 5
t1 loop 6
t2 loop 6
t1 loop 7
t2 loop 7
t1 loop 8
t2 loop 8
t1 loop 9
t2 loop 9
```

对比：

**实例1**是实现了**Runnable接口**，**实例2**继承了**Thread类**。

在**run()**方法中都有**synchronized(this)**，实例1的结果是先执行线程t1再执行线程t2，实例2的结果是线程t1和t2交替执行。

分析：

**synchronized(this)**是指当前对象，即synchronized(this)所在类对应的对象。它的作用是获取当前对象的同步锁。

对于实例2中的synchronized(this)中的this代表的是Mythread对象，t1和t2是两个不同的Mythread对象。因此t1和t2在执行synchronized(this)时获得的是不同对象的同步锁。

对于实例1来说，synchronized(this)中的this代表的是MyRunnable对象，t1和t2是共同一个MyRunnable对象。

因此，一个线程获取了对象的同步锁，会造成另外一个线程的等待。

**第二条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**仍然可以访问**该对象**的**非同步代码块**。

```java
package com.zjl.javase.thread;

public class SyncAndNoSync {
	public static void main(String[] args) {
		class Count{
			// 含有synchronized同步块的方法
			public void sync() {
				synchronized(this) {
					for (int i = 0; i < 5; i++) {
						try {
							Thread.sleep(100);
							System.out.println(Thread.currentThread().getName() + " sync loop " +i);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
					
				}
				
			}
			// 非同步的方法
			public void nosync() {
				for (int i = 0; i < 5; i++) {
					try {
						Thread.sleep(100);
						System.out.println(Thread.currentThread().getName() + " nosync loop " +i);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}
		
		 final Count count = new Count();
	     // 新建t1, t1会调用“count对象”的synMethod()方法
		 Thread t1 = new Thread(new Runnable() {
			
			public void run() {
				
				count.sync();
			}
		},"t1");
		 // 新建t2, t2会调用“count对象”的nonSynMethod()方法
		 Thread t2 = new Thread(new Runnable() {
				
				public void run() {
					count.nosync();
					
				}
			},"t2");
		 
		 t1.start();
		 t2.start();

	}
}

运行结果：
t1 sync loop 0
t2 nosync loop 0
t1 sync loop 1
t2 nosync loop 1
t1 sync loop 2
t2 nosync loop 2
t1 sync loop 3
t2 nosync loop 3
t1 sync loop 4
t2 nosync loop 4
```

结果说明：

线程t1和t2交替执行。t1会调用count对象的sync()方法，该方法中含有同步块；而t2则会调用count对象的nosync()方法，该方法不是同步方法。

t1运行时，虽然调用**synchronized(this)**获取**count对象的同步锁**；但是并没有造成t2阻塞，因为t2没有用到**count对象的同步锁**。

**第三条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**其他的synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

```java
package com.zjl.javase.thread;

public class SyncAndSync {
	public static void main(String[] args) {
		class Count{
			// 含有synchronized同步块的方法
			public void sync() {
				synchronized(this) {
					for (int i = 0; i < 5; i++) {
						try {
							Thread.sleep(100);
							System.out.println(Thread.currentThread().getName() + " sync loop " +i);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
					
				}
				
			}
            // 也包含synchronized同步块的方法
			public void sync2() {
				synchronized(this) {
					
					for (int i = 0; i < 5; i++) {
						try {
							Thread.sleep(100);
							System.out.println(Thread.currentThread().getName() + " sync2 loop " +i);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
					
				}
			}
		}
		
		 final Count count = new Count();
	     // 新建t1, t1会调用“count对象”的synMethod()方法
		 Thread t1 = new Thread(new Runnable() {
			
			public void run() {
				
				count.sync();
			}
		},"t1");
		 // 新建t2, t2会调用“count对象”的Syn2Method()方法
		 Thread t2 = new Thread(new Runnable() {
				
				public void run() {
					count.sync2();
					
				}
			},"t2");
		 
		 t1.start();
		 t2.start();

	}
}

运行结果：
t1 sync loop 0
t1 sync loop 1
t1 sync loop 2
t1 sync loop 3
t1 sync loop 4
t2 sync2 loop 0
t2 sync2 loop 1
t2 sync2 loop 2
t2 sync2 loop 3
t2 sync2 loop 4
```

结果说明：

t1和t2运行时都调用synchronized(this)，这个this时Count对象（count），而t1和t2共同count。

因此，在t1运行时，t2会被阻塞，等待t1运行释放"count对象的同步锁"，t2才能运行。

## 4.3 synchronized方法和synchronized代码块

### 4.3.1 概述

​	**synchronized方法**是用synchronized修饰方法，这是一种**粗粒度锁**；这个同步方法（非static）无需显式指定同步监视器，同步方法的同步监视器是**this**，也就是调用该方法的对象。

​	**synchronized代码块**是synchronized修饰代码块，这是一种**细粒度锁**；线程开始执行同步代码块前，必须先获得对同步监视器的锁定，任何时候只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。

​	虽然java允许使用任何对象作为同步监视器，但是同步监视器的目的就是为了阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源充当同步监视器。

```java
package com.zjl.javase.thread;

public class synchronizedTest {
	public static void main(String[] args) {
		class Demo {
			public synchronized void syncMethod() {
				for (int i = 0; i < 999999999; i++) {
					
				}
			}
			
			public void syncBlock() {
				synchronized(this) {
					for (int i = 0; i < 999999999; i++) {
						
					}
				}
			}
		}
		
		Demo demo = new Demo();
		long start,diff;
		start = System.currentTimeMillis();
		demo.syncMethod();   // 调用“synchronized方法块”
		diff = System.currentTimeMillis() -start; // 获取“时间差值”
		System.out.println(" syncMethod() : "+diff);
		
		start = System.currentTimeMillis();
		demo.syncBlock();  // 调用“synchronized方法块”
		diff = System.currentTimeMillis() -start; // 获取“时间差值”
		System.out.println(" syncBlock() : "+diff);
		
	}
}

运行结果：
 syncMethod() : 3
 syncBlock() : 2
```

结果说明：

**synchronized代码块**可以**更精确**的控制冲突限制访问区域，有时候表现**更高效**。

## 4.4 实例锁和全局锁

### 4.4.1 概念

​	实例锁：锁在某个实例对象上，如果该类是单例，那么该锁也具有全局锁的概念，实例锁对应的就是synchronized关键字。

​	全局锁：该锁针对的是类，无论实例多少个对象，那么线程都共享锁。全局锁对应的就是static synchronized（或是锁在该类上的class或者classloader对象上）。

### 4.4.2 实例

关于**实例锁**和**全局锁**很好的例子：

```java
package com.zjl.javase.thread;

public class Something {
	public synchronized void isSyncA() {
		
	}
	
	public synchronized void isSyncB() {
		
	}
	
	public static  synchronized void cSyncA() {
		
	}
	
	public static synchronized void cSyncB() {
		
	}	
	
}
```

假设，类Something有两个实例（对象）分别为x和y。分析下面4组表达式获取锁的情况。
(1)  x.isSyncA()与x.isSyncB()
(2)  x.isSyncA()与y.isSyncA()
(3)  x.cSyncA()与y.cSyncB()
(4)  x.isSyncA()与Something.cSyncA()

```java
package com.zjl.javase.thread;

public class LockTest {
	static class Something {
		public synchronized void isSyncA() {
			for(int i=0;i<5;i++){
                try {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName()+" : isSyncA " +i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
		}
		
		public synchronized void isSyncB() {
			for(int i=0;i<5;i++){
                try {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName()+" : isSyncB " +i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
		}
		
		public static synchronized void cSyncA() {
			for(int i=0;i<5;i++){
                try {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName()+" : cSyncA " +i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
		}
		
		public static synchronized void cSyncB() {
			for(int i=0;i<5;i++){
                try {
                    Thread.sleep(100);
                    System.out.println(Thread.currentThread().getName()+" : cSyncB " +i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
		}	
		
	}
	
	Something x = new Something();
	Something y = new Something();
	
	private void test1() {
		Thread t11 = new Thread(new Runnable(){
            public void run() {
               // x.isSyncA();    
                x.cSyncA();
            }
        },"t11");

        Thread t12 = new Thread(new Runnable(){
            public void run() {
             //   x.isSyncB();
             //   y.isSyncA();
                y.cSyncB();
                //Something.cSyncA();
            }
        },"t12");

        t11.start();
        t12.start();
	}
	
	public static void main(String[] args) {
		LockTest lockTest1 = new LockTest();
        lockTest1.test1();
	}
	
	
}
```

#### 4.4.2.1 x.isSyncA()与x.isSyncB() 不能同时访问

因为， x.isSyncA()与x.isSyncB()都是访问的同一个对象（对象x）的同步锁。

```java
运行结果：
t11 : isSyncA 0
t11 : isSyncA 1
t11 : isSyncA 2
t11 : isSyncA 3
t11 : isSyncA 4
t12 : isSyncB 0
t12 : isSyncB 1
t12 : isSyncB 2
t12 : isSyncB 3
t12 : isSyncB 4
```

#### 4.4.2.2 x.isSyncA()与y.isSyncA()能同时访问

因为，访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。
代码只需要在4.4.2.1上的代码将x.isSyncA() 和y.isSyncA()的注释去掉，其他的语句加上注释。

```java
运行结果：
t11 : isSyncA 0
t12 : isSyncA 0
t12 : isSyncA 1
t11 : isSyncA 1
t12 : isSyncA 2
t11 : isSyncA 2
t11 : isSyncA 3
t12 : isSyncA 3
t12 : isSyncA 4
t11 : isSyncA 4
```

#### 4.4.2.3 x.cSyncA()与y.cSyncB() 不能同时被访问

因为cSyncA()和cSyncB()都是**static类型**，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。
代码只需要在4.4.2.1上的代码将 x.cSyncA()与y.cSyncB() 的注释去掉，其他的语句加上注释。

```java
运行结果：
t11 : cSyncA 0
t11 : cSyncA 1
t11 : cSyncA 2
t11 : cSyncA 3
t11 : cSyncA 4
t12 : cSyncB 0
t12 : cSyncB 1
t12 : cSyncB 2
t12 : cSyncB 3
t12 : cSyncB 4
```

#### 4.4.2.4 x.isSyncA()与Something.cSyncA() 可以被同时访问

因为**isSyncA()是实例方法**，x.isSyncA()使用的是**对象x的锁**；而**cSyncA()是静态方法**，Something.cSyncA()可以理解对使用的是“**类的锁**”。因此，它们是**可以被同时访问**的。
代码只需要在4.4.2.1上的代码将 x.isSyncA()与Something.cSyncA() 的注释去掉，其他的语句加上注释。

```java
运行结果：
t11 : isSyncA 0
t12 : cSyncA 0
t12 : cSyncA 1
t11 : isSyncA 1
t11 : isSyncA 2
t12 : cSyncA 2
t11 : isSyncA 3
t12 : cSyncA 3
t11 : isSyncA 4
t12 : cSyncA 4
```

# 五、volatile 关键字

## 5.1 java 内存模型

![](java内存模型.jpg)

​	所有的变量都是存储在主内存中，每个线程都是独立的工作内存，里面保存该线程使用到的变量的副本。线程对共享变量的所有操作必须在自己的工作内存，不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值传递需要通过主内存来完成。

例如：线程1对共享变量的修改，要想被线程2及时看到，必须经过两个过程：

（1）把工作内存1中更新过的变量刷新到主内存中。

（2）将主内存中最新的共享变量的值更新到线程2中。

## 5.2 基本概念

### 5.2.1 可见性

​	指线程之间的可见性，一个线程该状态对另外一个线程可见。

​	**volatile修饰的变量**就**具有可见性**。volatile修饰的变量**不允许线程内部缓存和重排序**，**即直接修改内存**。但是，volatile修饰的变量**不具有原子性**。

比如：volatile int  a = 0; 之后有一个操作 a++ ; 这个变量a 具有可见性，但是 a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。**在java 中volatile、synchronized和final具有可见性**。

### 5.2.2 原子性

 JVM中执行的最小单位，具有不可分割性。

比如：int a = 0；（a非long和double类型）这个操作是不可分割的，那么我们说这个操作是原子操作。

但是 a++ ;这个实际上就是a = a + 1 ;是可分割的，所以不具有原子操作。非原子操作都会存在线程安全问题,需要我们使用同步技术（synchronized）来让它变成一个原子操作。

一个操作是原子操作，那么我们称它具有原子性。

java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。

比如：AtomticInteger、AtomticLong、AtomticReference等

**在Java中synchronized和在lock、unlock中操作保证原子性。**

### 5.2.3 有序性

​	java语言提供volatile和synchronized两个关键来保证线程之间操作的有序性。

​	volatile是因为其本身有禁止指令重排的。

​	synchronized是由一个变量在同一时刻只允许在一个线程对其操作，也就决定了持有同一个对象锁的两个同步块只能串行执行。

## 5.3 volatile 原理

​	java语言中提供了一种**稍微同步机制，即volatile变量**。用来确保变量的更新操作通知其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作仪器重排序。

volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在**读取volatile类型变量时总会返回最新写入的值**。在**访问volatile变量时不会被执行加锁操作**，因此也就**不会重新执行线程阻塞**，**volatile变量是一种比synchronized关键字轻量级的同步机制。**

总的来说，当一个变量被volatile修饰后，**不但具有可见性，而且还禁止指令重排**。volatile的**读性能消耗与普通变量几乎相同**，但是**写操作就慢一些**，因为它**要保证本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行**。

# 六、对线程等待和唤醒的方法

## 6.1 常用方法介绍

在Object类中，定义了wait()、notify()、notifyAll()等接口。

wait()的作用是让当前线程进入等待状态，同时，wait()也会让出当前线程，释放它所持有的锁。

而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；

notify()是唤醒单个线程；

而notifyAll()是唤醒所有的线程。

|           API接口            |                           API说明                            |
| :--------------------------: | :----------------------------------------------------------: |
|           notify()           |               唤醒此对象监视器上等待的单个线程               |
|         notifyAll()          |               唤醒此对象监视器上等待的所有线程               |
|            wait()            | 让当前线程处于"等待（阻塞）状态"，直到其他线程调用此对象notify()方法或notifyAll()方法，当前线程被唤醒（进入“就绪状态”） |
|      wait(long timeout)      | 让当前线程处于"等待（阻塞）状态"，直到其他线程调用此对象notify()方法胡总notifyAll()方法或超过指定的时间量，当前线程被唤醒（进入“就绪状态”） |
| wait(long timeout,int nanos) | 让当前线程处于"等待（阻塞）状态"，直到其他线程调用此对象notify()方法或notifyAll()方法或其他某个线程中断当前线程或已超过某个实际时间量，当前线程被唤醒（进入"就绪状态"） |

## 6.2 wait() 和 notify()示例

```java
public class WaitTest {

	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		class ThreadA extends Thread{
			
			public ThreadA(String name){
				super(name);
			}
			
			@Override
			public void run() {
				synchronized(this){
					System.out.println(Thread.currentThread().getName()+" 正在执行");
					
					System.out.println(Thread.currentThread().getName()+" 现在要执行， call notify()");
					notify();
				}
				
			}
		}

		  ThreadA t1 = new ThreadA("t1");
		  
		  synchronized(t1){
			  //启动线程t1
			  System.out.println(Thread.currentThread().getName()+" start t1");
			  t1.start();
			  			 
			  try {
				//主线程等待t1通过 notify（）唤醒。
				System.out.println(Thread.currentThread().getName()+" wait()");
				t1.wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			  
			  System.out.println(Thread.currentThread().getName()+" continue");
			  
		  }
	}

}

```





































