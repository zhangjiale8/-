# 一、并行与并发

```
并行：多个CPU实例或是多台机器同时执行一段处理逻辑，是真正的同时。
```

```
并发：通过CPU调度算法，让用户看上去同时执行，实际上从CPU操作层面并不是真正的同时。
并发往往需要公共的资源，对公共资源的处理和线程之间的协调是并发的难点重点。
```

## 1.1 并发与并行比较：

 	 如果你想要一个程序运行的更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。并发是用于多处理器编程的基本工具。为了使程序运行得更快，你必须学习如何利用这些额外的处理器，而则正是并发赋予你的能力。
  如果你有一台多处理器的机器，那么就可以在这些处理器之间分部多个任务，从而可以极大的提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每一个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。
  
  **但是，并发通常是提高运行在单处理器上的程序的性能**。
  
  因为，在单处理器上运行的并发程序开销应该比改程序的所有部分都顺序执行的开销大，因为其中增加了所谓的**上下文切换的代价（从一个任务切换到另一个任务）**。表面上看，将程序的所有部分当作单个的任务运行好像是开销更小一点，并且可以节省上下文切换的代价。
  使得这个问题变得有些不同的是**阻塞**。如果程序中的某个任务因为该程序控制范围之外的某系条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或现场**阻塞**了。如果没有并发，则整个程序都将停止下来，直到外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。事实上，从性能的角度看，如果没有任务阻塞，那么在单处理器上使用并发就没有任何意义。
  在单处理器系统中的性能提高的常见实例是**事件驱动的编程**。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。这也是在Android系统中不允许子线程总访问UI的原因，在Android中的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。那为什么系统不对UI控件的访问加上锁机制呢？原因有两个：其一，加上锁会让UI访问的逻辑变的复杂；其二，锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。所以在Android系统中最简单而且高效的方法就是采用单线程模型来处理UI操作。

## 1.2 进程和线程

​	实现并发最直接的方式是在操作系统级别使用**进程**。进程是运行在它自己的地址空间内的自包容的程序。

​	多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个（进程）程序，尽管这使得每个进程看起来在其执行过程中都是歇歇停停。进程被操作系统互相隔开，因此不会彼此干涉，这使得用进程编程相对容易一些。

​	与此相反，像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编程编写多线程程序最基本的困难在于，**协调不同线程驱动的任务之间对这些资源的使用，以便使得这些资源不会同时被多个任务访问**。

# 二、基础概念

## 2.1 线程状态图

![](线程状态图.jpg)

### 2.1.1 线程5种状态

1.新建（ New）：线程对象被创建时，它只会短暂的处于这种状态。此时它已经分配了必须的系统资源，并执行了初始化。

例如：Thread  thread = new Thread();

2.就绪（Runnable）：称为"可执行状态"。线程对象被创建后，其他线程调用了该对象的start()方法，从而启动该线程。

例如：thread.start();

处于就绪状态的线程，随时可能被CPU调度执行。

3.运行（Running）：线程获取CPU权限进行执行。

```
注意：
线程只能从就绪状态进入运行状态
```

 4.阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

```
阻塞的三种情况：
（1）等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。
（2）同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。
（3）其他阻塞：通过调用线程的sleep()或者发出I/O请求时，线程会进入阻塞状态。当sleep()状态超时、join()等待线程终止或超时。或是I/O处理完毕时，线程重新转入就绪状态。
```

5.死亡（Dead）：线程执行完或者因为异常退出run()方法，该线程结束生命周期。

## 2.2 关键字与关键函数

线程的5中状态（新建、就绪、运行、阻塞、死亡）涉及的内容包括Object类，Thread类和synchronized关键字。

```
在Object类中，定义了wait()、notify()、notifyAll()等一系列休眠/唤醒函数。
```

```
在Thread类中，定义了一系列线程操作函数，例如：sleep()休眠函数、interrupt()中断函数、getName()获取线程名称等。
```

```
synchronized关键字：synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。
```

# 三、常用的实现多线程的两种方式

## 3.1 概述

常用的实现多线程的两种方式：Thread和Runnable。之所以说是"常用"，是因为**在java5后可以通过java.until.concurrent包中的线程池来实现多线程**。（[线程进阶.md]( [线程进阶.md](线程进阶.md) )）

Runnable是一个接口，该接口包含了一个**run()**方法，Runnable具有更好的扩展性。

Thread是一个类，**Thread本身是实现了Runnable接口**。

此外，**Runnable还可以用于"资源共享"。即，多个线程都是基于某个Runnable对象创建的，它们会共享Runnable对象上的资源**。

## 3.2 实现多线程实例

### 3.2.1 定义任务（Runnable）

线程可以驱动任务，因此需要一种描述任务的方式。

在Java中用Runnable接口来提供，需要定义任务，只需要实现Runnable接口并编写run()方法，使得该任务可以执行命令。

```java
package com.zjl.javase.thread;

public class RunnableTest {
	public static void main(String[] args) {
		class MyRunnable implements Runnable{
			private int tickets = 10;
			public void run() {
				for (int i = 0; i < 20; i++) {
					if(this.tickets > 0) {
						System.out.println(Thread.currentThread().getName()+ "卖票：	   			tickets"+this.tickets --);
					}
				}
				
			}
			
		}
        // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！这说明它们是共享了	MyRunnable接口的。
		MyRunnable runnable = new MyRunnable();
		Thread t1 = new Thread(runnable);
		Thread t2 = new Thread(runnable);
		Thread t3 = new Thread(runnable);
		t1.start();
		t2.start();
		t3.start();
		
	}
}

运行结果：

Thread-1卖票：tickets10
Thread-1卖票：tickets7
Thread-1卖票：tickets6
Thread-1卖票：tickets5
Thread-1卖票：tickets4
Thread-1卖票：tickets3
Thread-1卖票：tickets2
Thread-1卖票：tickets1
Thread-2卖票：tickets9
Thread-0卖票：tickets8

```

### 3.2.2 继承Thread类

将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。

```java
package com.zjl.javase.thread;

public class ThreadTest {
	public static void main(String[] args) {
		class MyThread extends Thread {
			private int tickets = 10;
			@Override
			public void run() {
				for (int i = 0; i < 20; i++) {
					if(this.tickets > 0){
						System.out.println(this.getName()+"买票：ticket"+this.tickets--);
					}
				}
			}
			
		}
		
		// 启动3个线程t1,t2,t3；每个线程各卖10张票！
        // 和上面的结果对比，并揣摩 “Runnable还可以用于“资源共享”。即，多个线程都是基于某个Runnable对象建立的，它们会共享Runnable对象上的资源”这句话。
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();
		MyThread t3 = new MyThread();
		t1.start();
		t2.start();
		t3.start();
	}
}


运行结果：
Thread-0买票：ticket10
Thread-1买票：ticket10
Thread-0买票：ticket9
Thread-0买票：ticket8
Thread-0买票：ticket7
Thread-0买票：ticket6
Thread-2买票：ticket10
Thread-2买票：ticket9
Thread-2买票：ticket8
Thread-2买票：ticket7
Thread-2买票：ticket6
Thread-2买票：ticket5
Thread-2买票：ticket4
Thread-2买票：ticket3
Thread-2买票：ticket2
Thread-2买票：ticket1
Thread-1买票：ticket9
Thread-1买票：ticket8
Thread-1买票：ticket7
Thread-1买票：ticket6
Thread-1买票：ticket5
Thread-1买票：ticket4
Thread-1买票：ticket3
Thread-1买票：ticket2
Thread-1买票：ticket1
Thread-0买票：ticket5
Thread-0买票：ticket4
Thread-0买票：ticket3
Thread-0买票：ticket2
Thread-0买票：ticket1
```

# 四、synchronized 关键字

## 4.1 概述

​	**synchronized关键字是为了解决共享资源竞争的问题**，共享资源一般是**以对象形式存在的内存片段**，但也可以是文件、输入/输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问的这个资源的方法标记为synchronized。如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为synchronized方法的线程都会被阻塞。所有对象都自动含有**单一的锁（也称为监视器）**。当在对象上调用其任意synchronized方法的时候，对象都被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。 
  **在Java中，每个对象有且仅有一个同步锁**。这也意味着，**同步锁是依赖于对象而存在的**。当我们调用某个对象的synchronized方法时，就获得了该对象的同步锁，不同线程对同步锁的访问是互斥的。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为**互斥量（mutex）**。


## 4.2 synchronized 基本原则和实例

### 4.2.1 基本原则

synchronized的基本原则总结如下：

**第一条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**该synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

**第二条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**仍然可以访问**该对象**的**非同步代码块**。

**第三条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**其他的synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

### 4.2.2 实例

**第一条**：当一个线程访问**某个对象**的**synchronized方法**或**synchronized代码块**时，**其他线程**对**该对象**的**该synchronized方法**或**synchronized代码块**的访问将被**阻塞**。

```
package com.zjl.javase.thread;

public class RunnableTest {
	public static void main(String[] args) {
		class MyRunnable implements Runnable{
			private int tickets = 5;
			public void run() {
				synchronized(this){
					for (int i = 0; i < 5; i++) {
							try {
								Thread.sleep(100);
								System.out.println(Thread.currentThread().getName()+" loop " +i);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
					}
				}
				
			}
			
		}
		
		Runnable runnable = new MyRunnable();
		Thread t1 = new Thread(runnable,"t1");
		Thread t2 = new Thread(runnable,"t2");
		t1.start();
		t2.start();
	}
}

运行结果：
t1 loop 0
t1 loop 1
t1 loop 2
t1 loop 3
t1 loop 4
t2 loop 0
t2 loop 1
t2 loop 2
t2 loop 3
t2 loop 4
```

总结：

run()方法中存在synchronized(this)代码块，而且t1和t2都市基于MyRunnable这个Runnable对象创建的线程。这意味着，我们能可以将synchronized(this)中的this看作是MyRunnable这个Runnable对象；因此，线程t1和t2共享"MyRunnable对象的同步锁"。所以当一个线程运行时，另外一个线程必须等待正在运行的线程释放MyRunnable的同步锁之后才能运行。

