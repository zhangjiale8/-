# 一、并行与并发

```
并行：多个CPU实例或是多台机器同时执行一段处理逻辑，是真正的同时。
```

```
并发：通过CPU调度算法，让用户看上去同时执行，实际上从CPU操作层面并不是真正的同时。
并发往往需要公共的资源，对公共资源的处理和线程之间的协调是并发的难点重点。
```

## 1.1 并发与并行比较：

 	 如果你想要一个程序运行的更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。并发是用于多处理器编程的基本工具。为了使程序运行得更快，你必须学习如何利用这些额外的处理器，而则正是并发赋予你的能力。
  如果你有一台多处理器的机器，那么就可以在这些处理器之间分部多个任务，从而可以极大的提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每一个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。
  
  **但是，并发通常是提高运行在单处理器上的程序的性能**。
  
  因为，在单处理器上运行的并发程序开销应该比改程序的所有部分都顺序执行的开销大，因为其中增加了所谓的**上下文切换的代价（从一个任务切换到另一个任务）**。表面上看，将程序的所有部分当作单个的任务运行好像是开销更小一点，并且可以节省上下文切换的代价。
  使得这个问题变得有些不同的是**阻塞**。如果程序中的某个任务因为该程序控制范围之外的某系条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或现场**阻塞**了。如果没有并发，则整个程序都将停止下来，直到外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。事实上，从性能的角度看，如果没有任务阻塞，那么在单处理器上使用并发就没有任何意义。
  在单处理器系统中的性能提高的常见实例是**事件驱动的编程**。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。这也是在Android系统中不允许子线程总访问UI的原因，在Android中的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。那为什么系统不对UI控件的访问加上锁机制呢？原因有两个：其一，加上锁会让UI访问的逻辑变的复杂；其二，锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。所以在Android系统中最简单而且高效的方法就是采用单线程模型来处理UI操作。

## 1.2 进程和线程

​	实现并发最直接的方式是在操作系统级别使用**进程**。进程是运行在它自己的地址空间内的自包容的程序。

​	多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个（进程）程序，尽管这使得每个进程看起来在其执行过程中都是歇歇停停。进程被操作系统互相隔开，因此不会彼此干涉，这使得用进程编程相对容易一些。

​	与此相反，像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编程编写多线程程序最基本的困难在于，**协调不同线程驱动的任务之间对这些资源的使用，以便使得这些资源不会同时被多个任务访问**。

# 二、基础概念

## 2.1 线程状态图

![](线程状态图.jpg)

### 2.1.1 线程5种状态

1.新建（ New）：线程对象被创建时，它只会短暂的处于这种状态。此时它已经分配了必须的系统资源，并执行了初始化。

例如：Thread  thread = new Thread();

2.就绪（Runnable）：称为"可执行状态"。线程对象被创建后，其他线程调用了该对象的start()方法，从而启动该线程。

例如：thread.start();

处于就绪状态的线程，随时可能被CPU调度执行。

3.运行（Running）：线程获取CPU权限进行执行。

```
注意：
线程只能从就绪状态进入运行状态
```

 4.阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

```
阻塞的三种情况：
（1）等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。
（2）同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。
（3）其他阻塞：通过调用线程的sleep()或者发出I/O请求时，线程会进入阻塞状态。当sleep()状态超时、join()等待线程终止或超时。或是I/O处理完毕时，线程重新转入就绪状态。
```

5.死亡（Dead）：线程执行完或者因为异常退出run()方法，该线程结束生命周期。

## 2.2 关键字与关键函数

线程的5中状态（新建、就绪、运行、阻塞、死亡）涉及的内容包括Object类，Thread类和synchronized关键字。

```
在Object类中，定义了wait()、notify()、notifyAll()等一系列休眠/唤醒函数。
```

```
在Thread类中，定义了一系列线程操作函数，例如：sleep()休眠函数、interrupt()中断函数、getName()获取线程名称等。
```

```
synchronized关键字：synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。
```

# 三、常用的实现多线程的两种方式

## 3.1 概述

常用的实现多线程的两种方式：Thread和Runnable。之所以说是"常用"，是因为**在java5后可以通过java.until.concurrent包中的线程池来实现多线程**。（[线程进阶.md]( [线程进阶.md](线程进阶.md) )）

Runnable是一个接口，该接口包含了一个**run()**方法，Runnable具有更好的扩展性。

Thread是一个类，**Thread本身是实现了Runnable接口**。

此外，**Runnable还可以用于"资源共享"。即，多个线程都是基于某个Runnable对象创建的，它们会共享Runnable对象上的资源**。

## 3.2 实现多线程实例

### 3.2.1 定义任务（Runnable）

线程可以驱动任务，因此需要一种描述任务的方式。

在Java中用Runnable接口来提供，需要定义任务，只需要实现Runnable接口并编写run()方法，使得该任务可以执行命令。

```java
package com.zjl.javase.thread;

public class RunnableTest {
	public static void main(String[] args) {
		class MyRunnable implements Runnable{
			private int tickets = 10;
			public void run() {
				for (int i = 0; i < 20; i++) {
					if(this.tickets > 0) {
						System.out.println(Thread.currentThread().getName()+ "卖票：	   			tickets"+this.tickets --);
					}
				}
				
			}
			
		}
        // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！这说明它们是共享了	MyRunnable接口的。
		MyRunnable runnable = new MyRunnable();
		Thread t1 = new Thread(runnable);
		Thread t2 = new Thread(runnable);
		Thread t3 = new Thread(runnable);
		t1.start();
		t2.start();
		t3.start();
		
	}
}

运行结果：

Thread-1卖票：tickets10
Thread-1卖票：tickets7
Thread-1卖票：tickets6
Thread-1卖票：tickets5
Thread-1卖票：tickets4
Thread-1卖票：tickets3
Thread-1卖票：tickets2
Thread-1卖票：tickets1
Thread-2卖票：tickets9
Thread-0卖票：tickets8

```

### 3.2.2 继承Thread类