```
提到数据一致性、操作原子性，我相信大多数人可能会想到“锁”。在单体应用时代，我们使用jvm提供的锁就可以很好的工作，但是到了分布式应用时代，jvm提供的锁就行不通了，那么势必要借助一些跨jvm的临界资源来支持锁的相关语义，比如redis，zookeeper等
```

#  1.基于redis来实现的分布式锁

## 1.1 **加锁过程分析**

![](锁相关资源\基于redis的分布式锁.jpg)

### 1.1.1 初期疑惑及解答

```
Q1：为什么不使用 SET key value [expiration EX seconds|PX milliseconds] [NX|XX]  这个指令来实现key的自动过期呢，反而放到应用代码判断key是否过期？

A1：我们的分布式锁开发的时候SET命令还不支持NX、PX，所以才想出这种办法来实现key过期，NX、PX在2.6.12以后开始支持；

Q2：已经判断了当前key对应的时间戳已经过期了，为什么还要使用getset再获取一次呢，直接使用set指令覆盖不可以吗？

A2：这里其实牵扯到并发的一些事情，如果直接使用set，那有可能多个客户端会同时获取到锁，如果使用getset然后判断旧值是否过期就不会有这个问题，设想一下如下场景：

1、C1加锁成功，不巧的是，这时C1意外的奔溃了，自然就不会释放锁；

2、C2，C3尝试加锁，这时key已存在，所以C2，C3去判断key是否已过期，这里假设key已经过期了，所以C2，C3使用set指令去设置值，那两个都会加锁成功，这就闯大祸了；如果使用getset指令，然后判断下返回值是否过期就可以避免这种问题，假如C2跑的快，那C3判断返回的时间戳已经过期，自然就加锁失败；
```

