# 1.1 基本常识表

![img](images\数据类型基本常识表.png)

上图有以下几点需要注意：

（1）java八种基本数据类型分为四类八种，四类分别为整型、浮点型、布尔型、字符型；八种分别为byte、short、int、long、float、double、boolean、char；

（2）java八种基本数据类型的字节数:分别为1、2、4、8个字节；1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)；

（3）整数的默认类型为int，浮点数的默认类型为double；

（4）八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写

（5）关于值的范围问题，需要注意char类型是无符号的，不能为负，所以是0开始的；

## 1.1.1 包装类型作用及基本类型区别

**包装类型的出现是为了方便对基本类型进行操作。包装类型可以解决一些基本类型解决不了的问题**，如下：

（1）**集合不允许存放基本类型数据，只能存放引用类型数据**，比如包装类型。以List为例,大家都知道一个动态数组的add(Object o)方法只能接受一个引用类型。

（2）**基本类型和包装类之间可以相互转换，又叫自动装箱与自动拆箱。这个特性让我们在编码的时候能够更注重于业务的开发，而不是每转换一次就需要写一堆转换代码**。

（3）通过包装类型可以实现8种基本数据类型+String类型 之间可以相互转换，如：

```Java
 int num = Integer.parseInt("1");
```


（4）有时候一个函数需要传递一个Object变量 而你想传递int类型的进去显然不行，这就要用到包装类。如下代码：

```Java
public void test(Object obj){
}
//想传递5进去就可以这样
test(new Integer(5));
```

# 1.2 直接量与类型转换

## 1.2.1 直接量

```Java
@Test
public void d() {
    int a=100;//这个100就是直接量
    a=a+100;//但是这个a+100不是直接量
    double b=3.14;
}
```

## 1.2.2 类型转换

### 1.2.2.1 **自动转换：低类型的向高类型的转换**

​    如下图：顺着箭头的方向是可以自动转换的；

![](images\数据类型转化.png)

### 1.2.2.2 **强制转换：高类型的向底类型转换，但可能会数据溢出或者精度丢失**

### 1.2.2.3 以上现象在实际应用：

#### 1.2.2.3.1 **定义变量时出现的类型转换**

```java
@Test
public void e(){
    long a=200;//200是直接量，默认为int类型这里是自动转换为弄类型

    /*long b=100000000000;*/
    //100000000000是个整数直接量，默认应该为int类型，但是超出了int类型的取值范围

    long c=1000000000000L;
    //在整数直接量后面将了一个L，表示该直接量不再默认为int类型，为long类型，所以没错

    /*float d=34.3;*/
    //浮点型直接量默认为double,double类型大，所以不能直接转换为float

    float e=34.3f;
    //在浮点数直接量后面加上一个f，表示该直接量不再默认为double，为float类型
}
```

 注意：以上为几种正常的情况，但是有一种特殊的情况，就是**int型直接量可以直接赋给byte、short、char类型变量，只要不超出变量类型的取值范围**

```java
@Test 
public void f() {
    byte a=100;
    short b=200;
    char c=100;//注意char类型是一种特殊的int类型，可以不用写成单引号括起来的

    /*byte d=128;直接量128超出了byte类型的取值范围*/

    /*char e=-1;直接量-1不在char类型的取值范围内*/

}
```

#### 1.2.2.3.2 **数据运算时的类型转换**

（1）运算时，运算结果会向较大的类型转换

```java
@Test
public void g() {
    int a=3;
    double b=4;
    System.out.println(a+b);//输出7.0

    float c=3.2f;
    /*c=c+3.14; 编译错误,运算之后变为double类型*/	
}
```

（2）特殊的：byte、short、char三种数据类型参与运算时，先一律转化为int类型；

```java
@Test
public void h() {
    byte a=3;
    byte b=4;
    /*byte c=a+b;
		 * 编译错误,此处由于byte类型参与运算时，先直接转换为int类型，
		 * 所以最后的结果也是int类型，但是得出的结果不能叫做int类型的直接量，所以编译错误
		 * */
    int d=a+b;
}
```

#### 1.2.2.3.3 **强制转换**

高等级转为低等级的时候，必须强制转换，但实际工作中不推荐使用强制转换，可能会失精度或数据溢出；

```java
@Test
public void j() {
    int a=128;
    byte b=(byte)a;
    System.out.println(b);//输出-128，出现了数据溢出

    double c=1.23;
    int d=(int)c;
    System.out.println(d);//输出1，精度丢失
}
```

​    **补充说明：**不是只有强制转换的时候会出现数据，例如下面这种情况

```java
@Test
public void k() {
    int a=10000000;
    int b=10000000;
    int c=a*b;
    System.out.println(c);//输出276447232，得到的结果超出了int类型的范围，数据溢出
}
```

# 1.3 基本数据类型对应包装类及使用

## 1.3.1 基本介绍

 java是一门面向对象的语言，但是8中基本数据类型不具备面向对象的特征，所以实际使用中很不便所以为java八种基本数据类型提供了对应的包装类。

| 基本数据类型 | 对应包装类          | 包装类的父类     |
| ------------ | ------------------- | ---------------- |
| byte         | java.lang.Byte      | java.lang.Number |
| short        | java.lang.Short     | java.lang.Number |
| int          | java.lang.Integer   | java.lang.Number |
| long         | java.lang.Long      | java.lang.Number |
| float        | java.lang.Float     | java.lang.Number |
| double       | java.lang.Double    | java.lang.Number |
| boolean      | java.lang.Boolean   | java.lang.Object |
| char         | java.lang.Character | java.lang.Object |

（1）对应包装类比较特殊的就是int对应的Integer和char对应的Character；

（2）对应包装类的直接父类：前6个由于是数，直接父类为Number，而后两个的直接父类就是Object类；

## 1.3.2 静态方法 valueOf()

（1）**参数为基本数据类型，返回包装类对象**；

（2）参数为String字符串（Character类没有以String为 参数的该方法）,返回包装类对象；

```java
@Test
public void a() {
    /*1.参数为基本数据类型		
	 * 作用：将基本数据类型转换为对应包装类 * */
    Integer i=Integer.valueOf(10);
    System.out.println(i);//输出10

    /*2.参数为String字符串时，
	 * 作用：返回指定字符串值的包装类对象
	 * 	*/
    Integer a=Integer.valueOf("100");
    System.out.println(a);//输出100

    Integer b=Integer.valueOf("100a")
    System.out.println(b);//运行错误，字符串的值不少一个int类型的

}
```

## 1.3.3 静态方法parseXXX(String str)

（1）Character类没有该方法；

（2）作用：**将字符串装换为对应的基本数据类型**（注意此处和上面的valueOf方法返回值的不同）；

```java
@Test
public void b() {
    /*作用：将给定字符串装换为对应的基本数据类型
		 * 前提是该字符串必须正确描述该基本数据类型表示的值*/
    int a=Integer.parseInt("100");
    System.out.println(a);//输出100

    int b=Integer.parseInt("100a");
    System.out.println(b);//运行错误，字符串的值不为int类型

}
```

## 1.3.4 非静态方法XXXValue()

（1）因为是非静态方法，所以不能像上面两个方法用类名调用了；

（2）数字类的包装类（八种包装类中父类是Number的的六个类）才有该方法；

（3）作用：将当前包装类对象转换为对应的基本数据类型；

```java
@Test
public void c() {
    /*作用：将包装类对象转换为对应的基本数据类型*/

    Integer a=Integer.valueOf(100);//将基本数据类型转换为包装类对象
    int b=a.intValue();//将包装类对象转换为对应的基本数据类型
    System.out.println(b);//输出100

    Double c=Double.valueOf(2.33);
    double d=c.doubleValue();
    System.out.println(d);
}
```

## 1.3.5 自动拆箱与装箱

- 简介：jdk1.5之后的新特性。该特性是编译器认可的，是在编译器自动将基本数据类型和包装类相互转换，节省了麻烦。

（1）自动拆箱 包装类——>基本数据类型** (原理是调用了xxxValue方法)  

（2）**自动装箱** **基本数据类型——>包装类** (原理是调用了valueOf方法)

```java
@Test
public void d() {
    /*自动装箱：valueOf*/
    Integer i=123;//原理是 Integer i=Integer.valueOf(123);

    /*自动拆箱*/
    int i1=i+1;//原理是	int i1=i.intValue()+1;

    Integer a=123;
    Integer b=123;
    Integer c=a+b;
    /*原理为Integer c=Integer.valueOf(a.intValue()+b.intValue());*/
}
```

## 1.3.6 关于valueOf()方法源码

通过按住Ctrl键，鼠标点击该方法即可查看源码，以Integer类的valueOf(int i)的源码为例

```Java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

**关于源码的理解：Integer类的valueOf(int i)方法首先会判断i是否在\**-128~127\**之间，如果在的话，就返回的对象是Integer类中\**静态数组\**\**cache\**中的对象，如果不是在这之间，就会重写创建一个新的对象。**

**通过查看其它类的该方法的源码之后，可以得到该表：**

| 包装类    | valueOf(X i)返回对象的原则                                   |
| --------- | ------------------------------------------------------------ |
| Byte      | 直接取，数组范围为（-128,127），且byte值的范围也是（-128,127） |
| Short     | （-128，127）之间在数组中取，否则new                         |
| Integer   | （-128，127）之间在数组中取，否则new                         |
| Long      | （-128，127）之间在数组中取，否则new                         |
| Float     | 直接new                                                      |
| Double    | 直接new                                                      |
| Boolean   | 直接返回，不new                                              |
| Character | 0-127之间从数组中取，否则new                                 |

# 1.4 相关面试题

## 1.4.1 类型转换

- 注意一些喜欢忽视的类型转换

```java
public static void main(String[] args) {
    int a=10;
    double b=3.4;
    System.out.println(a>b?a:b);
    System.out.println(a);
}
/*输出：10.0   10
解析：这里是一个很容易让人不注意的类型转化，这里a与b参与了运算，
所以类型向类型大的方向转化，10就变成了10.0，但是a本身是没有变化的*/
```

## 1.4.2 +=的情况

```java
public static void main(String[] args) {
    short a=1;	//第一行
    a=a+1;		//第二行
    a+=1;		//第三行
}
/*第几行的代码会出错？
答案：第二行会出错，由于a+1变为了int类型,而int类型不能直接赋值给short类型
但是+=这种情况是特殊的，所以不会出错；
*/
```

## 1.4.3 自动装箱

- 包装类和基本数据类型比较时，只要值相等就相等

```java
public static void main(String[] args) {
    Integer a1=127;
    Integer a2=127;
    int a3=127;
    Integer b1=128;
    Integer b2=128;
    int b3=128;
    System.out.println(a1==a2);
    System.out.println(a1==a3);
    System.out.println(b1==b2);
    System.out.println(b1==b3);	
}
/*输出：true true false true
解析：自动装箱时采用valueOf方法，由于127在静态数组的范围内，所以不是new的，
而128的两个引用是指向new出现对象的，所以第一个是true，第三个是false。
而包装类和基本数据类型比较时，只要数值是相等的，就相等
*/
```

## 1.4.4 char类型存储汉字

**char类型能不能存储一个汉字？为什么？**

 **解析：能，char类型采用的是Unicode编码，Unicode编码包含汉字，所以char类型自然是可以存储一个汉字的**

## 1.4.5 浮点数精度问题

```java
public static void main(String[] args) {
		System.out.println(0.1*3==0.3);
		System.out.println(0.1*4);
}
/*输出：false 0.4
解析：有些浮点数不能准确的表示出来，与整数相乘之后出精度丢失，常见为小数位含3的
*/
```





原文链接1：https://blog.csdn.net/pinkdaddy/article/details/82756790?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

原文链接2：https://blog.csdn.net/qq_37688023/article/details/85106894