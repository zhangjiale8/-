# 1 定义：

​	在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。

# 2 角色：

  **抽象构件角色（Project）：**给出一个接口，以规范准备接收附加责任的对象。

  **具体构件角色（Employe）：**定义一个将要接收附加责任的类。

  **装饰角色（Manager）：**持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。

 **具体装饰角色（ManagerA、ManagerB）：**负责给构件对象“贴上”附加的责任。

# 3 示例：

## 3.1 公共接口：

```Java
public interface Person {  
    void eat();  
}
```

## 3.2 被装饰对象：

```Java
public class OldPerson implements Person {  
    @Override  
    public void eat() {  
        System.out.println("吃饭");  
    }  
}
```

## 3.3 装饰对象：

```Java
public class NewPerson implements Person {  
    private OldPerson p;  
 
    NewPerson(OldPerson p) {  
        this.p = p;  
    }  
 
    @Override  
    public void eat() {  
        System.out.println("生火");  
        System.out.println("做饭");  
        p.eat();  
        System.out.println("刷碗");   
    }  
}
```

## 3.4 测试：

```java
public class PersonDemo {  
    public static void main(String[] args) {  
        OldPerson old = new OldPerson();  
        //old.eat(); 
        NewPerson np = new NewPerson(old);  
        np.eat();  
    }  
}
```



通过例子可以看到，没有改变原来的OldPerson类，同时也没有定义他的子类而实现了Person的扩展，这就是装饰者模式的作用。

# 4 优点：

* 使用装饰者模式比使用继承更加灵活，因为它选择通过一种动态的方式来扩展一个对象的功能，在运行时可以选择不同的装饰器，从而实现不同的行为。
* 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。
* 具体构件类与具体装饰类可以独立变化，他能是低耦合的。用户可以根据需要来增加新的具体构件类和具体装饰类，在使用时再对其进行各种组合，原有代码无须改变，符合“开闭原则”。

# 5 缺点：

* 会产生很多的小对象，增加了系统的复杂性
* 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

 

# 6 装饰者与适配者模式的区别：

* 适配器模式主要用来兼容那些不能在一起工作的类，使他们转化为可以兼容目标接口，虽然也可以实现和装饰者一样的增加新职责，但目的不在此。装饰者模式主要是给被装饰者增加新职责的。
* 适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。
* 适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。

# 7 装饰者和继承的区别：

## 7.1 继承：

* 优点：代码结构清晰，而且实现简单
* 缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。

## 7.2 装饰者：

* 优点：内部可以通过多态技术对多个需要增强的类进行增强
* 缺点：需要内部通过多态技术维护需要增强的类的实例。进而使得代码稍微复杂。

# 8 使用场景：

* 需要扩展一个类的功能，或给一个类添加附加职责。
* 需要动态的给一个对象添加功能，这些功能可能不明确或者暂时的，可以随时很方便的动态撤销掉。
* 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
* 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类



原文链接： https://www.javazhiyin.com/476.html