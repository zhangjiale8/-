

# 2019.09.18

```
开闭原则相关的面向对象设计原则（）多选题哦
A、里氏代换原则(Liskov Substitution Principle LSP)
B、依赖倒转原则（Dependence Inversion Principle）
C、接口隔离原则（Interface Segregation Principle）
D、复用原则
```

```
正确答案: A B C
面向对象共有六大原则：开闭原则、单一职责原则、里式替换原则、依赖倒置原则、接口隔离原则、迪米特法则。
开闭原则：开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。
单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。
里式替换原则：“子类能够替换基类，否则不应当设计为其子类。”也就是说，子类只能去扩展基类，而不是隐藏或覆盖基类。
依赖倒置原则：模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的。
接口隔离原则：客户端不应该依赖他不需要的接口。
迪米特法则：一个对象应该对其他对象保持最小的了解。
```

# 2019.09.23

```
JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：(    )
A、HttpSessionAttributeListener
B、HttpSessionBindingListener
C、HttpSessionObjectListener
D、HttpSessionListener;
E、HttpSession
F、HttpSessionActivationListener
```

```
正确答案：A
答案解析：HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；
HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；
HttpSessionObjectListener：没有该接口API；
HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；
HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。
```

# 2019.09.24

```
java程序内存泄露的最直接表现是（ ）
A、频繁FullGc
B、jvm崩溃
C、程序抛内存控制的Exception
D、java进程异常消失

```

```
正确答案：C
答案解析：java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值
但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.
最终超出内存界限，抛出OutOfMemoryExpection
```

# 2019.09.25

```
以下会产生信息丢失的类型转换是( ）
A.     float  a=10
B.     int a=（int）8846.0
C.     byte  a=10； int b=-a
D.    double d=100
```

```
正确答案：B
答案解析：会产生信息丢失不如说丢失精度，这样可能更容易明白，而精度丢失只会发生在从大范围到小范围的转换。
上面四个选项，只有 B 是从 double 到 int ，也就是从大范围到小范围。
```

# 2019.09.26

```
关于protected 修饰的成员变量，以下说法正确的是
A、可以被该类自身、与它在同一个包中的其它类、在其它包中的该类的子类所访问
B、只能被该类本身和该类的所有的子类访问
C、只能被该类自身所访问
D、只能被同一个包中的类访问
```

```
正确答案：A
答案解析：
1、protected访问控制符能被用于方法和成员变量。
2、声明为protected的方法和成员变量能被同一个包里的所有类所访问，就像默认修饰符package一样。
3、能被该类的子类所访问，子类可以和父类不在一个包中。
```

